import { Controller } from "@nestjs/common";
import { TypedRoute, TypedParam, TypedBody } from "@nestia/core";
import typia, { tags } from "typia";
import { getCommunityPlatformRegisteredMemberUsersUserId } from "../../../../providers/getCommunityPlatformRegisteredMemberUsersUserId";
import { RegisteredmemberAuth } from "../../../../decorators/RegisteredmemberAuth";
import { RegisteredmemberPayload } from "../../../../decorators/payload/RegisteredmemberPayload";
import { putCommunityPlatformRegisteredMemberUsersUserId } from "../../../../providers/putCommunityPlatformRegisteredMemberUsersUserId";
import { deleteCommunityPlatformRegisteredMemberUsersUserId } from "../../../../providers/deleteCommunityPlatformRegisteredMemberUsersUserId";

import { ICommunityPlatformUser } from "../../../../api/structures/ICommunityPlatformUser";

@Controller("/communityPlatform/registeredMember/users/:userId")
export class CommunityplatformRegisteredmemberUsersController {
  /**
   * Get a single account detail from community_platform_users by ID.
   *
   * Return one user account record from the Prisma model
   * community_platform_users identified by id. The model contains id, email,
   * email_normalized, username, username_normalized, password_hash,
   * display_name?, last_login_at?, created_at, updated_at, and deleted_at?. Per
   * schema comments, email_normalized and username_normalized enforce
   * case-insensitive uniqueness; they are internal and should not be exposed.
   * The password_hash column is strictly confidential and must never appear in
   * responses.
   *
   * Security and permissions: Any authenticated user may retrieve only their
   * own account; enforcement occurs in provider logic by comparing the path
   * userId to the authenticated principal. Site administrators may be allowed
   * to read any account according to policy. Soft-deleted accounts (deleted_at
   * set) should typically be inaccessible to regular users unless policy
   * requires otherwise.
   *
   * Relationships and context: Although a user is related to sessions, role
   * flags, communities, posts, comments, and votes, this endpoint focuses on
   * the primary account entity. Additional aggregates or flags (e.g.,
   * isSiteAdmin) may be computed by looking up rows in
   * community_platform_siteadmins and community_platform_registeredmembers.
   *
   * Validation and errors: The path parameter userId must be a valid UUID. If
   * the record does not exist or is not accessible to the caller, return a
   * not-found or permission-denied error consistent with platform standards.
   * Temporary errors should produce the standard recoverable message for
   * clients.
   *
   * @param connection
   * @param userId Target user’s unique identifier (UUID)
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Get()
  public async at(
    @RegisteredmemberAuth()
    registeredMember: RegisteredmemberPayload,
    @TypedParam("userId")
    userId: string & tags.Format<"uuid">,
  ): Promise<ICommunityPlatformUser> {
    try {
      return await getCommunityPlatformRegisteredMemberUsersUserId({
        registeredMember,
        userId,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Update a user profile in community_platform_users by ID.
   *
   * Modify an existing user record in Prisma model community_platform_users
   * addressed by id. The table contains id, email, email_normalized, username,
   * username_normalized, password_hash, optional display_name, last_login_at,
   * created_at, updated_at, and optional deleted_at. Based on schema comments,
   * normalized columns enforce CI uniqueness; when updating email or username,
   * the application should compute and persist the normalized forms
   * consistently while validating uniqueness.
   *
   * Security and permissions: Only the account owner should be allowed to
   * update their own profile fields under normal policy; a site administrator
   * may override when necessary for compliance. This API must ignore attempts
   * to modify password_hash and never echo it back. It must also prevent
   * updates to immutable identifiers such as id and to server-managed
   * timestamps (created_at, updated_at) except for system logic.
   *
   * Relationships and constraints: This operation does not directly manipulate
   * sessions, role assignment tables, or content authored by the user. If
   * username/email changes are permitted, ensure downstream references and
   * caches reconcile appropriately. Soft-deleted users (deleted_at set) should
   * be considered inactive/uneditable unless reactivation is implemented
   * separately.
   *
   * Error handling: Validate UUID format for userId. Enforce email/username
   * case-insensitive uniqueness; on conflict return 409 with a suitable
   * message. For forbidden ownership cases, return 403. On transient failures,
   * return the standard temporary error message.
   *
   * @param connection
   * @param userId Target user’s unique identifier (UUID)
   * @param body Fields to update for the user profile (e.g., display_name,
   *   optional username/email per policy)
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Put()
  public async update(
    @RegisteredmemberAuth()
    registeredMember: RegisteredmemberPayload,
    @TypedParam("userId")
    userId: string & tags.Format<"uuid">,
    @TypedBody()
    body: ICommunityPlatformUser.IUpdate,
  ): Promise<ICommunityPlatformUser> {
    try {
      return await putCommunityPlatformRegisteredMemberUsersUserId({
        registeredMember,
        userId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Deactivate a user (set deleted_at) in community_platform_users by ID.
   *
   * Permanently remove a user account from normal visibility by marking it as
   * deleted in the community_platform_users table. The Prisma schema defines
   * deleted_at as an optional timestamp, enabling a soft deletion pattern. This
   * operation should set deleted_at to the current timestamp to deactivate the
   * account without dropping related records. The record will be excluded from
   * standard queries unless explicitly included for compliance.
   *
   * Security and permissions: Typically, an authenticated user may request
   * deactivation for their own account, and a site administrator may deactivate
   * any account when required for policy/legal reasons. Business logic must
   * verify authority before proceeding. After deactivation, existing sessions
   * should be revoked via community_platform_sessions according to policy, and
   * write actions must be blocked for the deactivated account.
   *
   * Relationships and behavior: Content authored by the user (communities,
   * posts, comments, votes) remains in place per platform policy; this API does
   * not cascade hard deletions. If additional cleanup is required, perform it
   * in service logic while maintaining auditability. To reverse deactivation,
   * implement a separate restore process that clears deleted_at under strict
   * authorization.
   *
   * Error handling: Validate userId as UUID. If the account is already
   * deactivated (deleted_at not null), the operation may be idempotent. On
   * success, return 204 No Content with no response body. For forbidden
   * actions, return 403. For transient errors, surface the standard temporary
   * error message.
   *
   * @param connection
   * @param userId Target user’s unique identifier (UUID)
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Delete()
  public async erase(
    @RegisteredmemberAuth()
    registeredMember: RegisteredmemberPayload,
    @TypedParam("userId")
    userId: string & tags.Format<"uuid">,
  ): Promise<void> {
    try {
      return await deleteCommunityPlatformRegisteredMemberUsersUserId({
        registeredMember,
        userId,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
