import { Controller } from "@nestjs/common";
import { TypedRoute, TypedParam, TypedBody } from "@nestia/core";
import typia, { tags } from "typia";
import { putCommunityPlatformRegisteredMemberCommunitiesCommunityNameMembership } from "../../../../../providers/putCommunityPlatformRegisteredMemberCommunitiesCommunityNameMembership";
import { RegisteredmemberAuth } from "../../../../../decorators/RegisteredmemberAuth";
import { RegisteredmemberPayload } from "../../../../../decorators/payload/RegisteredmemberPayload";
import { deleteCommunityPlatformRegisteredMemberCommunitiesCommunityNameMembership } from "../../../../../providers/deleteCommunityPlatformRegisteredMemberCommunitiesCommunityNameMembership";

import { ICommunityPlatformCommunityMember } from "../../../../../api/structures/ICommunityPlatformCommunityMember";

@Controller(
  "/communityPlatform/registeredMember/communities/:communityName/membership",
)
export class CommunityplatformRegisteredmemberCommunitiesMembershipController {
  /**
   * Update current user’s community membership via
   * community_platform_community_members.
   *
   * Update the calling user’s membership in a specific community. The Prisma
   * schema models communities with community_platform_communities, including
   * immutable name, name_key for case-insensitive uniqueness, and timestamps
   * like created_at and last_active_at. Memberships are represented by
   * community_platform_community_members with references to users and
   * communities, and include created_at/updated_at timestamps and a deleted_at
   * column that should be respected by queries.
   *
   * Security and permissions: Authentication is required. Any registered member
   * may join or leave a community. Joining does not convey moderation
   * privileges. Ownership checks are not required beyond validating the acting
   * user’s identity.
   *
   * Validation and business logic: Resolve the community using {communityName}
   * (normalize to name_key). If the body indicates join=true and no active
   * membership exists, insert a row and set created_at. If a historical row
   * exists that is not considered active, reactivate it by clearing removal
   * markers and updating updated_at. If join=false and an active membership
   * exists, remove it from active consideration so that it no longer appears in
   * membership queries that require deleted_at to be null. Update
   * community_platform_recent_communities.last_activity_at for the caller to
   * ensure the Left Sidebar reflects the latest state. Compute and return the
   * current memberCount as the number of active membership rows for the
   * community.
   *
   * Related operations: /me/recentCommunities for recency display; GET
   * /communities/{communityName} for community details; and the user
   * memberships listing endpoint. This write is idempotent relative to the
   * intended final state.
   *
   * Error handling: If unauthenticated, return an authorization error aligned
   * with standardized copy. If the target community does not exist or is not
   * visible, return not-found. Temporary failures should return the
   * standardized temporary error and no partial state should be exposed to
   * clients.
   *
   * @param connection
   * @param communityName Immutable community name used to resolve the target
   *   community (application normalizes to name_key).
   * @param body Desired membership state payload, e.g., { join: true } to join
   *   or { join: false } to leave.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Put()
  public async update(
    @RegisteredmemberAuth()
    registeredMember: RegisteredmemberPayload,
    @TypedParam("communityName")
    communityName: string &
      tags.MinLength<3> &
      tags.MaxLength<30> &
      tags.Pattern<"^[A-Za-z0-9](?:[A-Za-z0-9_-]*[A-Za-z0-9])$">,
    @TypedBody()
    body: ICommunityPlatformCommunityMember.IUpdate,
  ): Promise<ICommunityPlatformCommunityMember> {
    try {
      return await putCommunityPlatformRegisteredMemberCommunitiesCommunityNameMembership(
        {
          registeredMember,
          communityName,
          body,
        },
      );
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Leave a community by deleting the caller’s membership row
   * (community_platform_community_members).
   *
   * This endpoint removes the authenticated user’s membership link to a target
   * community. The relationship is stored in the
   * community_platform_community_members table, which contains foreign keys to
   * community_platform_users (as the joining account) and
   * community_platform_communities (as the target community). The community is
   * resolved by the provided communityName path parameter, which maps to the
   * immutable name field and its normalized name_key for case-insensitive
   * uniqueness. The membership table enforces a unique constraint on
   * [community_platform_user_id, community_platform_community_id], ensuring a
   * single row represents membership and enabling idempotent join/leave
   * semantics.
   *
   * Security and permissions follow the business rules that joining and leaving
   * communities require authentication. Only the currently authenticated
   * account may create or remove its own membership rows. Administrative roles
   * are not required for this operation, and leaving a community never alters
   * moderation or ownership rights. The controller/provider resolves the caller
   * from the session and executes the deletion against the appropriate
   * membership row when present.
   *
   * From a data and relationship standpoint, removal of the membership may
   * influence personalization features such as the Home feed (which is derived
   * from joined communities) and can update auxiliary records like
   * community_platform_recent_communities for last-activity ordering. Community
   * existence is validated against community_platform_communities; if the
   * community name does not resolve, the operation fails with a not-found
   * outcome. If the user is not currently a member, the operation is
   * effectively a no-op but still succeeds to preserve idempotence and
   * responsive UI flows.
   *
   * Error handling and behavior expectations: the operation returns no response
   * body on success. Providers should implement standard error mappings (e.g.,
   * 401 when unauthenticated) and may return a not-found error when the
   * community cannot be resolved by name. Rate limiting may be applied to
   * protect service stability during bursts of toggling. The underlying foreign
   * key relations in community_platform_community_members use Cascade delete
   * toward both the user and community entities, but this endpoint itself
   * performs a straightforward membership unlink for the current user.
   *
   * @param connection
   * @param communityName Immutable community name used to resolve the target
   *   community.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Delete()
  public async erase(
    @RegisteredmemberAuth()
    registeredMember: RegisteredmemberPayload,
    @TypedParam("communityName")
    communityName: string,
  ): Promise<void> {
    try {
      return await deleteCommunityPlatformRegisteredMemberCommunitiesCommunityNameMembership(
        {
          registeredMember,
          communityName,
        },
      );
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
