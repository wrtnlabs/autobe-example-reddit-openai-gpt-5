import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody } from "@nestia/core";
import typia from "typia";
import { patchcommunityPlatformSearchComments } from "../../../../providers/patchcommunityPlatformSearchComments";

import { IPageICommunityPlatformComment } from "../../../../api/structures/IPageICommunityPlatformComment";
import { ICommunityPlatformComment } from "../../../../api/structures/ICommunityPlatformComment";

@Controller("/communityPlatform/search/comments")
export class CommunityplatformSearchCommentsController {
  /**
   * Search comments (community_platform_comments) with Newest ordering and
   * paginated results.
   *
   * This operation retrieves searchable, paginated comments from the community
   * platform in alignment with the business requirements and the Prisma schema.
   * It is rooted in the community_platform_comments table, which stores
   * user-authored comment entities with fields including id (primary key),
   * community_platform_post_id (post association), community_platform_user_id
   * (author association), optional parent_id (threading), content (plain-text
   * body), created_at, updated_at, and deleted_at. Text matching uses the
   * content column and leverages the defined trigram index (Gin on content) to
   * support efficient substring and similarity queries.
   *
   * Security and access follow product rules: reading and searching are open to
   * all roles, so this endpoint is public. Results must include only comments
   * that remain visible to the public: comments where deleted_at is null and
   * whose parent post and community are also available for public consumption
   * (exclude where post.deleted_at is not null or
   * community.disabled_at/deleted_at is not null). Implement reasonable rate
   * limiting or throttling for this search endpoint to mitigate abuse and
   * protect backend resources.
   *
   * The operation returns results ordered by the canonical Newest definition
   * for comments: order by created_at descending; when created_at timestamps
   * are equal, return the comment with the larger identifier first (effectively
   * ORDER BY created_at DESC, id DESC). The request body
   * ICommunityPlatformComment.IRequest encapsulates search criteria such as the
   * query string (minimum length 2 characters; shorter inputs must not execute
   * the search and should surface the standard validation message), pagination
   * controls targeting 20 results per page, and optional post/community
   * scoping. The response body IPageICommunityPlatformComment.ISummary wraps a
   * page of summary items optimized for list display, including essential
   * fields such as comment id, content excerpt, created_at, and minimal
   * relation hints (post/community identifiers) as defined in the DTO schema.
   *
   * This API is closely related to other search endpoints (e.g., posts and
   * communities) but focuses strictly on comments. Typical usage includes
   * executing a global search where the client selects the Comments tab and
   * then calls this endpoint with the user’s query. On error, the
   * implementation should provide consistent messages for validation failures
   * (e.g., “Please enter at least 2 characters.”) and handle transient issues
   * with a retry-friendly response, as specified in the error-handling
   * requirements. Timestamps should be presented in clients using users’ local
   * timezones (e.g., Asia/Seoul) with relative formatting, and pagination must
   * return 20 items per page with stable ordering and no duplicates between
   * pages.
   *
   * @param connection
   * @param body Search constraints and pagination parameters for comment
   *   retrieval (query ≥ 2 chars, pagination 20 per page).
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Patch()
  public async index(
    @TypedBody()
    body: ICommunityPlatformComment.IRequest,
  ): Promise<IPageICommunityPlatformComment.ISummary> {
    try {
      return await patchcommunityPlatformSearchComments({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
