import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody, TypedParam } from "@nestia/core";
import typia, { tags } from "typia";
import { patchcommunityPlatformReservedTerms } from "../../../providers/patchcommunityPlatformReservedTerms";
import { getcommunityPlatformReservedTermsReservedTermId } from "../../../providers/getcommunityPlatformReservedTermsReservedTermId";

import { IPageICommunityPlatformReservedTerm } from "../../../api/structures/IPageICommunityPlatformReservedTerm";
import { ICommunityPlatformReservedTerm } from "../../../api/structures/ICommunityPlatformReservedTerm";

@Controller("/communityPlatform/reservedTerms")
export class CommunityplatformReservedtermsController {
  /**
   * Search and paginate reserved terms (community_platform_reserved_terms).
   *
   * This operation lists records from community_platform_reserved_terms, which
   * the schema defines as an administrative list of reserved terms used to
   * validate and block specific names or identifiers (e.g., community names,
   * system-reserved words). Each record contains the original term, a
   * normalized variant for case-insensitive matching (term_normalized), the
   * applies_to context (such as 'community_name' or 'global'), an optional
   * reason, an active flag, and standard timestamps.
   *
   * Security posture: read-only and primarily administrative/reference in
   * nature, yet it may be publicly consumable depending on product policy. For
   * broad validation transparency, this document sets the endpoint as public
   * read. Implementations should filter out records where deleted_at is not
   * null. Additional filtering by active allows clients to see only enforced
   * terms when needed.
   *
   * Data and validation rules: the listing supports free-text search against
   * term (and optionally term_normalized), filtering by applies_to and active,
   * and sorting by created_at (default), term, or applies_to. Clients should
   * paginate results (page/limit or cursor approach) to keep responses
   * performant. Indices on term and term_normalized (trigram) support efficient
   * search behavior for partial matches.
   *
   * Related operations include GET /reservedTerms/{reservedTermId} for detail
   * retrieval. Expected behavior includes stable ordering within a page, clear
   * differentiation between empty results and invalid filters, and consistent
   * exclusion of records that have a non-null deleted_at value.
   *
   * @param connection
   * @param body Search, filter, sort, and pagination parameters for reserved
   *   terms
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Patch()
  public async index(
    @TypedBody()
    body: ICommunityPlatformReservedTerm.IRequest,
  ): Promise<IPageICommunityPlatformReservedTerm.ISummary> {
    try {
      return await patchcommunityPlatformReservedTerms({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Get a single reserved term (community_platform_reserved_terms) by ID.
   *
   * This operation loads one record from community_platform_reserved_terms
   * using the reservedTermId path parameter (UUID). Per the schema comments,
   * each reserved term captures the original term, a normalized version for
   * case-insensitive uniqueness, the target context via applies_to, an optional
   * reason explaining the reservation, an active flag, and lifecycle
   * timestamps. The uniqueness constraint on (applies_to, term_normalized)
   * guarantees consistent enforcement across contexts.
   *
   * Security considerations: this is a read-only endpoint and is configured as
   * public for transparency. Implementations should not return records with
   * deleted_at populated. If the identifier does not resolve to an existing
   * eligible record, return a not-found response.
   *
   * Validation and behavior: ensure the parameter is a valid UUID and that the
   * record exists. The response returns the reserved term entity only; related
   * validation logic that consumes these terms occurs elsewhere. Consistent
   * error handling and absence of internal details ensure stable client
   * integrations.
   *
   * @param connection
   * @param reservedTermId Unique identifier of the reserved term (UUID)
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Get(":reservedTermId")
  public async at(
    @TypedParam("reservedTermId")
    reservedTermId: string & tags.Format<"uuid">,
  ): Promise<ICommunityPlatformReservedTerm> {
    try {
      return await getcommunityPlatformReservedTermsReservedTermId({
        reservedTermId,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
