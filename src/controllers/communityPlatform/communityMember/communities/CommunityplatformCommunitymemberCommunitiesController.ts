import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody, TypedParam } from "@nestia/core";
import typia, { tags } from "typia";
import { postcommunityPlatformCommunityMemberCommunities } from "../../../../providers/postcommunityPlatformCommunityMemberCommunities";
import { CommunitymemberAuth } from "../../../../decorators/CommunitymemberAuth";
import { CommunitymemberPayload } from "../../../../decorators/payload/CommunitymemberPayload";
import { putcommunityPlatformCommunityMemberCommunitiesCommunityId } from "../../../../providers/putcommunityPlatformCommunityMemberCommunitiesCommunityId";
import { deletecommunityPlatformCommunityMemberCommunitiesCommunityId } from "../../../../providers/deletecommunityPlatformCommunityMemberCommunitiesCommunityId";

import { ICommunityPlatformCommunity } from "../../../../api/structures/ICommunityPlatformCommunity";

@Controller("/communityPlatform/communityMember/communities")
export class CommunityplatformCommunitymemberCommunitiesController {
  /**
   * Create a community (community_platform_communities) with immutable name,
   * category, and optional metadata.
   *
   * This operation creates a sub-community in the
   * community_platform_communities table. According to the schema comments, a
   * community stores an immutable unique name (name), optional description,
   * optional logo and banner URIs (logo, banner), belongs to an owner
   * (community_platform_user_id referencing community_platform_users), and is
   * categorized by community_platform_category_id referencing
   * community_platform_categories. The table also tracks last_active_at for
   * recent activity, disabled_at for administrative disablement, and standard
   * timestamps including created_at, updated_at, and a nullable deleted_at for
   * records no longer active.
   *
   * Security and permissions: Only authenticated users with creation capability
   * may call this endpoint; business logic must ensure the caller becomes the
   * owner (community_platform_user_id) of the new community. Ownership and
   * policy checks are enforced in the provider layer, including reserved term
   * checks (via community_platform_reserved_terms) and category availability
   * (active flag in community_platform_categories). The name is immutable
   * post-creation; application logic must reject attempts to modify it later.
   * The system may also initialize related display elements (e.g.,
   * last_active_at to now) consistent with the schema’s purpose.
   *
   * Validation rules and business logic: The community name must be globally
   * unique (@@unique([name])) and conform to PRD format constraints
   * (letters/digits/hyphen/underscore, length 3–32, case-insensitive
   * uniqueness). The chosen category must reference a valid
   * community_platform_categories.id that is active. Optional description can
   * be present; logo and banner should be valid URIs stored as strings. On
   * successful creation, downstream features like membership personalization
   * and explore pages will read from this record, and related rules may be
   * added later via the rules management endpoints.
   *
   * Related operations: Use PUT
   * /communityPlatform/communityMember/communities/{communityId} to edit
   * metadata fields (not the name), DELETE
   * /communityPlatform/communityMember/communities/{communityId} to mark the
   * community as deleted for removal from public views, and PATCH
   * /communityPlatform/communities/{communityId}/rules to retrieve the
   * community’s ordered rule items. Error handling includes name conflicts,
   * invalid format, and invalid category ID. The response returns the full
   * community entity for client display and subsequent navigation.
   *
   * @param connection
   * @param body Creation payload including immutable name, required category
   *   reference, and optional metadata fields.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post()
  public async create(
    @CommunitymemberAuth()
    communityMember: CommunitymemberPayload,
    @TypedBody()
    body: ICommunityPlatformCommunity.ICreate,
  ): Promise<ICommunityPlatformCommunity> {
    try {
      return await postcommunityPlatformCommunityMemberCommunities({
        communityMember,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Update community metadata (community_platform_communities) except immutable
   * name.
   *
   * This operation updates a community record stored in
   * community_platform_communities. The schema specifies key fields: immutable
   * name (name), optional description, optional logo and banner URIs (logo,
   * banner), owner reference (community_platform_user_id), category reference
   * (community_platform_category_id), last_active_at, disabled_at (for
   * administrative disablement), and lifecycle timestamps. The name remains
   * immutable as per business rules and schema commentary; application logic
   * must reject attempts to alter it.
   *
   * Security and permissions: Only the community owner
   * (community_platform_user_id) or appropriately authorized actors (e.g.,
   * administrative capabilities) may update metadata. The endpoint requires
   * authentication with role-based gating; the provider function must verify
   * ownership and policy. The category change must reference an existing,
   * active community_platform_categories record. URIs for logo and banner are
   * stored as strings and should be validated at the application level.
   *
   * Validation and behavior: Keep the name unchanged, enforce allowed category,
   * and ensure presentation fields remain within expected limits. The
   * updated_at timestamp should reflect the modification. Related entities such
   * as community_platform_community_rules and memberships are unaffected by
   * this edit but may be displayed alongside the community. If a disabled_at
   * value exists, writing logic should respect that state (e.g., disallow
   * posting) but metadata edits by owners or admins may still be permitted per
   * policy.
   *
   * Related operations: POST /communityPlatform/communityMember/communities
   * creates a community; DELETE
   * /communityPlatform/communityMember/communities/{communityId} marks the
   * record as deleted (via deleted_at) to remove it from public access; PATCH
   * /communityPlatform/communities/{communityId}/rules lists ordered rules.
   * Errors include not found, permission denied, invalid category, and attempts
   * to modify immutable fields.
   *
   * @param connection
   * @param communityId Identifier of the community to update.
   * @param body Update payload for description, logo, banner, category, and
   *   related metadata (name is immutable and must not change).
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Put(":communityId")
  public async update(
    @CommunitymemberAuth()
    communityMember: CommunitymemberPayload,
    @TypedParam("communityId")
    communityId: string & tags.Format<"uuid">,
    @TypedBody()
    body: ICommunityPlatformCommunity.IUpdate,
  ): Promise<ICommunityPlatformCommunity> {
    try {
      return await putcommunityPlatformCommunityMemberCommunitiesCommunityId({
        communityMember,
        communityId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Mark a community (community_platform_communities) as deleted to remove it
   * from public access.
   *
   * This operation targets the community_platform_communities table to remove a
   * community from public access. The schema includes a nullable deleted_at
   * column indicating a record is no longer active. When invoked,
   * implementation sets deleted_at and ensures dependent surfaces exclude the
   * community and its content. The table also links to posts
   * (community_platform_posts), rules (community_platform_community_rules),
   * memberships (community_platform_community_memberships), and recent
   * communities (community_platform_recent_communities), which should be
   * excluded from public results once the community is marked deleted.
   *
   * Security and permissions: Only the owner (community_platform_user_id) or
   * authorized administrative actors may execute this removal. The provider
   * function must enforce ownership and policy checks. After the record is
   * marked deleted, content is removed from feeds (including
   * mv_community_platform_global_latest_posts), searches, and recent lists;
   * related memberships may be ended by setting their deleted_at as appropriate
   * in the membership table. This preserves audit trails while ensuring the
   * community no longer appears on public surfaces, in alignment with the
   * schema’s lifecycle fields.
   *
   * Behavior and errors: If the community does not exist or is already removed,
   * the provider should return a not-found or idempotent success consistent
   * with system conventions. Attempts by non-owners should be denied. No
   * response body is returned on success, and clients should update UI and
   * caches accordingly.
   *
   * @param connection
   * @param communityId Identifier of the community to remove from public
   *   access.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Delete(":communityId")
  public async erase(
    @CommunitymemberAuth()
    communityMember: CommunitymemberPayload,
    @TypedParam("communityId")
    communityId: string & tags.Format<"uuid">,
  ): Promise<void> {
    try {
      return await deletecommunityPlatformCommunityMemberCommunitiesCommunityId(
        {
          communityMember,
          communityId,
        },
      );
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
