import { Controller } from "@nestjs/common";
import { TypedRoute, TypedParam, TypedBody } from "@nestia/core";
import typia, { tags } from "typia";
import { postcommunityPlatformCommunityMemberCommunitiesCommunityIdRules } from "../../../../../providers/postcommunityPlatformCommunityMemberCommunitiesCommunityIdRules";
import { CommunitymemberAuth } from "../../../../../decorators/CommunitymemberAuth";
import { CommunitymemberPayload } from "../../../../../decorators/payload/CommunitymemberPayload";
import { putcommunityPlatformCommunityMemberCommunitiesCommunityIdRulesRuleId } from "../../../../../providers/putcommunityPlatformCommunityMemberCommunitiesCommunityIdRulesRuleId";
import { deletecommunityPlatformCommunityMemberCommunitiesCommunityIdRulesRuleId } from "../../../../../providers/deletecommunityPlatformCommunityMemberCommunitiesCommunityIdRulesRuleId";

import { ICommunityPlatformCommunityRule } from "../../../../../api/structures/ICommunityPlatformCommunityRule";

@Controller("/communityPlatform/communityMember/communities/:communityId/rules")
export class CommunityplatformCommunitymemberCommunitiesRulesController {
  /**
   * Create a community rule (community_platform_community_rules) for the
   * specified community.
   *
   * This operation inserts a new ordered rule item into the
   * community_platform_community_rules table for the community identified by
   * {communityId}. The schema describes these records as an ordered list
   * authored by the community owner, with order_index unique per community to
   * ensure deterministic display order and text limited to short guidance
   * (1–200 characters). The application should atomically persist the new item
   * with proper timestamps.
   *
   * Security and permissions: According to the business rules, only the
   * community owner may create or edit rules. The endpoint therefore requires
   * an authenticated user with ownership over the target community; further
   * authorization checks must be enforced in provider logic. While the endpoint
   * requires authentication (role "communityMember"), only owners pass the
   * ownership check.
   *
   * Relationships and constraints: The newly created rule references
   * community_platform_communities via community_platform_community_id.
   * Providers must ensure that the community exists, is not administratively
   * disabled in a way that forbids settings edits, and that order_index is
   * unique within that community. Input validation must enforce text length
   * (1–200 characters) in accordance with the schema commentary and product
   * constraints.
   *
   * Related operations: Use GET
   * /communityPlatform/communities/{communityId}/rules/{ruleId} to retrieve the
   * created rule, PUT to modify an existing one, and DELETE to remove a rule
   * when necessary.
   *
   * @param connection
   * @param communityId Parent community’s ID (UUID) that will own the new rule
   * @param body Rule creation payload including order and text constraints
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post()
  public async create(
    @CommunitymemberAuth()
    communityMember: CommunitymemberPayload,
    @TypedParam("communityId")
    communityId: string & tags.Format<"uuid">,
    @TypedBody()
    body: ICommunityPlatformCommunityRule.ICreate,
  ): Promise<ICommunityPlatformCommunityRule> {
    try {
      return await postcommunityPlatformCommunityMemberCommunitiesCommunityIdRules(
        {
          communityMember,
          communityId,
          body,
        },
      );
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Update a community rule in community_platform_community_rules.
   *
   * This operation modifies an existing rule in
   * community_platform_community_rules scoped by the provided {communityId} and
   * {ruleId}. The schema notes that each rule has an order_index (unique per
   * community) and a short text field for display. Updates should ensure that
   * the record remains associated with the same parent community and that
   * constraints are respected.
   *
   * Security and permissions: Editing community rules is restricted to the
   * community owner per the business rules. The endpoint requires an
   * authenticated user (role "communityMember") with ownership verified in
   * business logic. Non-owners attempting to edit must be denied with the
   * standard message.
   *
   * Validation and behavior: Providers should validate that the rule exists, is
   * active (deleted_at IS NULL), and belongs to the specified community.
   * Validate that the new order_index remains unique within the community and
   * that text remains within 1–200 characters. On success, updated_at should
   * reflect the modification. If the rule is missing or already removed, return
   * a not-found outcome at the business layer.
   *
   * Related operations: See GET for retrieval, POST for creation, and DELETE
   * for removal of rules.
   *
   * @param connection
   * @param communityId Parent community’s ID (UUID) that owns the rule
   * @param ruleId Target rule’s ID (UUID) to update
   * @param body Rule update payload (e.g., text and/or order_index) subject to
   *   constraints
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Put(":ruleId")
  public async update(
    @CommunitymemberAuth()
    communityMember: CommunitymemberPayload,
    @TypedParam("communityId")
    communityId: string & tags.Format<"uuid">,
    @TypedParam("ruleId")
    ruleId: string & tags.Format<"uuid">,
    @TypedBody()
    body: ICommunityPlatformCommunityRule.IUpdate,
  ): Promise<ICommunityPlatformCommunityRule> {
    try {
      return await putcommunityPlatformCommunityMemberCommunitiesCommunityIdRulesRuleId(
        {
          communityMember,
          communityId,
          ruleId,
          body,
        },
      );
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Logically remove a rule (set deleted_at) in
   * community_platform_community_rules.
   *
   * This operation performs a logical removal of a rule from
   * community_platform_community_rules by setting the deleted_at timestamp for
   * the row identified by {communityId} and {ruleId}. The schema explicitly
   * provides deleted_at as the soft deletion column; records with a non-null
   * value are considered removed from active views and should be excluded from
   * lists and detail retrievals.
   *
   * Security and permissions: Only the community owner is allowed to remove
   * rules per the business requirements. The endpoint requires an authenticated
   * user (role "communityMember"), with ownership verified in provider logic.
   * Attempts by non-owners must be denied using the standard message.
   *
   * Validation and behavior: Providers should ensure the rule exists, belongs
   * to the specified community, and is currently active (deleted_at IS NULL)
   * before performing the logical removal. After removal, the rule should be
   * excluded from feeds, search, and the Community Info + Rules box. If the
   * rule is already removed or not found, respond with the appropriate
   * not-found outcome at the business layer. Because this is a logical removal
   * using deleted_at, the operation does not physically delete the record,
   * preserving auditability.
   *
   * Related operations: Use GET to retrieve existing rules, POST to create new
   * rules, and PUT to edit rules before removal.
   *
   * @param connection
   * @param communityId Parent community’s ID (UUID) that owns the rule
   * @param ruleId Target rule’s ID (UUID) to logically remove
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Delete(":ruleId")
  public async erase(
    @CommunitymemberAuth()
    communityMember: CommunitymemberPayload,
    @TypedParam("communityId")
    communityId: string & tags.Format<"uuid">,
    @TypedParam("ruleId")
    ruleId: string & tags.Format<"uuid">,
  ): Promise<void> {
    try {
      return await deletecommunityPlatformCommunityMemberCommunitiesCommunityIdRulesRuleId(
        {
          communityMember,
          communityId,
          ruleId,
        },
      );
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
