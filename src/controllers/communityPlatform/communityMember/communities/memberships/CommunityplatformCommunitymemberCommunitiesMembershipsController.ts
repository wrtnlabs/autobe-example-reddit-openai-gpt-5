import { Controller } from "@nestjs/common";
import { TypedRoute, TypedParam, TypedBody } from "@nestia/core";
import typia, { tags } from "typia";
import { postcommunityPlatformCommunityMemberCommunitiesCommunityIdMemberships } from "../../../../../providers/postcommunityPlatformCommunityMemberCommunitiesCommunityIdMemberships";
import { CommunitymemberAuth } from "../../../../../decorators/CommunitymemberAuth";
import { CommunitymemberPayload } from "../../../../../decorators/payload/CommunitymemberPayload";
import { patchcommunityPlatformCommunityMemberCommunitiesCommunityIdMemberships } from "../../../../../providers/patchcommunityPlatformCommunityMemberCommunitiesCommunityIdMemberships";
import { deletecommunityPlatformCommunityMemberCommunitiesCommunityIdMembershipsMembershipId } from "../../../../../providers/deletecommunityPlatformCommunityMemberCommunitiesCommunityIdMembershipsMembershipId";

import { ICommunityPlatformCommunityMembership } from "../../../../../api/structures/ICommunityPlatformCommunityMembership";
import { IPageICommunityPlatformCommunityMembership } from "../../../../../api/structures/IPageICommunityPlatformCommunityMembership";

@Controller(
  "/communityPlatform/communityMember/communities/:communityId/memberships",
)
export class CommunityplatformCommunitymemberCommunitiesMembershipsController {
  /**
   * Join a community by creating a row in
   * community_platform_community_memberships.
   *
   * Join the target community by creating a new row in
   * community_platform_community_memberships. Per the Prisma schema,
   * memberships record the association between a user and a community and
   * include timestamps created_at and updated_at, with deleted_at indicating an
   * ended membership. The unique composite key on
   * (community_platform_community_id, community_platform_user_id) prevents
   * multiple active memberships.
   *
   * Security and permissions: This action requires authentication and should
   * only allow the authenticated user to create their own membership. Joining
   * confers no moderation privileges; it solely affects personalization and
   * feed inclusion consistent with the product rules. Provider logic should
   * also update community last_active_at
   * (community_platform_communities.last_active_at) where appropriate and may
   * record an audit event in community_platform_audit_logs (e.g., event_type =
   * "join_community").
   *
   * Validation: Validate communityId as a UUID referencing an existing,
   * joinable community (e.g., not administratively disabled via disabled_at
   * where policy forbids new joins). If a membership already exists and is
   * active, implementations should behave idempotently (return the existing
   * membership) or return a conflict depending on policy. If a prior membership
   * exists with deleted_at set, reactivation by clearing deleted_at and
   * updating updated_at can be applied per business rules.
   *
   * Related operations: Use PATCH /communities/{communityId}/memberships for
   * roster queries and DELETE
   * /communities/{communityId}/memberships/{membershipId} to end a membership.
   * These operations operate on the same
   * community_platform_community_memberships table.
   *
   * @param connection
   * @param communityId Target community’s ID
   *   (community_platform_communities.id)
   * @param body Creation payload; the server infers the acting user from the
   *   authenticated session. No additional fields required beyond path
   *   parameter.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post()
  public async create(
    @CommunitymemberAuth()
    communityMember: CommunitymemberPayload,
    @TypedParam("communityId")
    communityId: string & tags.Format<"uuid">,
    @TypedBody()
    body: ICommunityPlatformCommunityMembership.ICreate,
  ): Promise<ICommunityPlatformCommunityMembership> {
    try {
      return await postcommunityPlatformCommunityMemberCommunitiesCommunityIdMemberships(
        {
          communityMember,
          communityId,
          body,
        },
      );
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * List memberships for a community from
   * community_platform_community_memberships with filtering and pagination.
   *
   * Retrieve a filtered, sorted, and paginated list of membership rows from the
   * community_platform_community_memberships junction table. Per the Prisma
   * schema comments, this model captures the relationship between a user
   * (community_platform_users.id) and a community
   * (community_platform_communities.id) and is the source of truth for
   * join/leave history. Columns include id, community_platform_community_id,
   * community_platform_user_id, created_at, updated_at, and a deleted_at
   * timestamp used to indicate that a membership has been ended (leave time). A
   * unique composite index across (community_platform_community_id,
   * community_platform_user_id) prevents duplicate active memberships.
   *
   * Security and permissions: Membership rosters can be sensitive. Although
   * this route is authenticated (authorizationRoles: ["communityMember"]),
   * detailed access should be constrained in the provider to community owners
   * and platform administrators where appropriate. Non-owners may be limited to
   * their own membership state or redacted views. Rate limiting and audit
   * logging (community_platform_audit_logs) are recommended for administrative
   * queries.
   *
   * Entity relationships and behavior: Memberships belong to a community
   * (community_platform_communities) and a user (community_platform_users). The
   * endpoint must filter by the communityId path parameter and should (by
   * default) exclude rows where deleted_at is not null to return currently
   * joined members. When historical queries are needed, the request body can
   * include flags to include ended memberships and to filter by
   * created_at/updated_at ranges. Sorting should support created_at and
   * updated_at fields, and pagination should follow the platform’s standard
   * page/limit or cursor conventions.
   *
   * Validation and error handling: Validate communityId as a UUID that
   * references an existing, not-removed community. If the target community is
   * disabled (disabled_at set), the provider may still allow owners/admins to
   * view the roster but should prevent broader disclosure. Return 404 when the
   * community does not exist, and 400 for invalid parameters. Responses should
   * be stable and deterministic given the sort criteria, and must not include
   * content tied to records with deleted_at when the default active-only filter
   * applies.
   *
   * Related operations: Use POST /communities/{communityId}/memberships to join
   * (create) and DELETE /communities/{communityId}/memberships/{membershipId}
   * to end an existing membership. These operations work against the same
   * community_platform_community_memberships table while enforcing
   * authorship/ownership rules from the requirements.
   *
   * @param connection
   * @param communityId Target community’s ID
   *   (community_platform_communities.id)
   * @param body Search, filter, sort, and pagination parameters for community
   *   memberships
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Patch()
  public async index(
    @CommunitymemberAuth()
    communityMember: CommunitymemberPayload,
    @TypedParam("communityId")
    communityId: string & tags.Format<"uuid">,
    @TypedBody()
    body: ICommunityPlatformCommunityMembership.IRequest,
  ): Promise<IPageICommunityPlatformCommunityMembership.ISummary> {
    try {
      return await patchcommunityPlatformCommunityMemberCommunitiesCommunityIdMemberships(
        {
          communityMember,
          communityId,
          body,
        },
      );
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * End a community membership in community_platform_community_memberships
   * (logical removal via deleted_at).
   *
   * Remove a user’s membership by marking it ended in the
   * community_platform_community_memberships table. The schema defines
   * deleted_at to capture the leave time, allowing the record to remain
   * available for historical reporting. The membership row includes
   * community_platform_community_id, community_platform_user_id, created_at,
   * updated_at, and deleted_at. This operation must ensure that the
   * membershipId corresponds to the community specified by communityId and that
   * the actor is permitted to end this membership (either the member themself
   * or an authorized community owner/administrator per business rules).
   *
   * Security and permissions: Authentication is required. Authorization checks
   * should confirm that the requester is the membership owner or has sufficient
   * privileges (e.g., community owner or system administrator) to remove
   * another user’s membership. Providers should consider emitting an audit
   * entry in community_platform_audit_logs (event_type like "leave_community"
   * or a policy action for administrative removals) and may refresh community
   * last_active_at on change.
   *
   * Validation and behavior: Validate both communityId and membershipId as
   * UUIDs. If the membership is already ended (deleted_at set), the operation
   * should be idempotent. If membershipId does not belong to the communityId,
   * return 404. If the community is administratively disabled (disabled_at),
   * policy may still permit owners/admins to end memberships. On successful
   * completion, return a 204 No Content with no response body.
   *
   * @param connection
   * @param communityId Target community’s ID
   *   (community_platform_communities.id)
   * @param membershipId Membership row ID
   *   (community_platform_community_memberships.id) to end
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Delete(":membershipId")
  public async erase(
    @CommunitymemberAuth()
    communityMember: CommunitymemberPayload,
    @TypedParam("communityId")
    communityId: string & tags.Format<"uuid">,
    @TypedParam("membershipId")
    membershipId: string & tags.Format<"uuid">,
  ): Promise<void> {
    try {
      return await deletecommunityPlatformCommunityMemberCommunitiesCommunityIdMembershipsMembershipId(
        {
          communityMember,
          communityId,
          membershipId,
        },
      );
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
