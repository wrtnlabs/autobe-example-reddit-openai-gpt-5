import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody, TypedParam } from "@nestia/core";
import typia, { tags } from "typia";
import { patchCommunityPlatformSiteAdminUserRestrictions } from "../../../../providers/patchCommunityPlatformSiteAdminUserRestrictions";
import { SiteadminAuth } from "../../../../decorators/SiteadminAuth";
import { SiteadminPayload } from "../../../../decorators/payload/SiteadminPayload";
import { getCommunityPlatformSiteAdminUserRestrictionsRestrictionId } from "../../../../providers/getCommunityPlatformSiteAdminUserRestrictionsRestrictionId";

import { IPageICommunityPlatformUserRestriction } from "../../../../api/structures/IPageICommunityPlatformUserRestriction";
import { ICommunityPlatformUserRestriction } from "../../../../api/structures/ICommunityPlatformUserRestriction";

@Controller("/communityPlatform/siteAdmin/userRestrictions")
export class CommunityplatformSiteadminUserrestrictionsController {
  /**
   * Search user restriction assignments (community_platform_guestvisitors).
   *
   * This administrative operation returns a filtered, paginated set of user
   * restriction records sourced from community_platform_guestvisitors. Each
   * record links to a target user via community_platform_user_id and captures
   * enforcement state including restriction_type (business allowed values
   * include “read_only” and “suspended”), optional restricted_until (expiry),
   * optional restriction_reason, assigned_at when the restriction was applied,
   * and revoked_at when lifted. Standard audit fields include created_at and
   * updated_at, while deleted_at may be used for retention without immediate
   * physical removal.
   *
   * Security and permissions: access is limited to site administrators. The
   * provider MUST validate the caller’s administrative role (related to
   * community_platform_siteadmins). Non-admin callers must receive a 403 or 401
   * according to authentication/authorization status, using standardized
   * copies.
   *
   * Request and response structure: use the request body to supply filters such
   * as by restriction_type, active-only (revoked_at is null), time windows
   * using assigned_at or restricted_until, and pagination inputs (cursor,
   * limit). Sorting commonly defaults to Newest by created_at (desc, then id
   * desc). The response returns a page object containing data[] and pagination
   * info for continuation.
   *
   * Related operations: use GET /userRestrictions/{restrictionId} to retrieve a
   * single record by ID when deeper inspection is required. Creation or updates
   * of restriction states should be handled by dedicated admin workflows and
   * are not part of this read/search endpoint.
   *
   * @param connection
   * @param body Search criteria, filters, sorting, and pagination parameters
   *   for user restrictions.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Patch()
  public async index(
    @SiteadminAuth()
    siteAdmin: SiteadminPayload,
    @TypedBody()
    body: ICommunityPlatformUserRestriction.IRequest,
  ): Promise<IPageICommunityPlatformUserRestriction> {
    try {
      return await patchCommunityPlatformSiteAdminUserRestrictions({
        siteAdmin,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Get a specific user restriction (community_platform_guestvisitors).
   *
   * Get detailed information for a specific restriction record stored in
   * community_platform_guestvisitors. The record includes id (UUID),
   * community_platform_user_id (the affected account), restriction_type (values
   * such as “read_only” or “suspended”), restricted_until (optional),
   * restriction_reason (optional), assigned_at (start), and revoked_at
   * (optional). Standard audit fields created_at and updated_at are present,
   * and deleted_at may be used for retention without immediate physical
   * removal.
   *
   * Security and permissions: this detail retrieval is restricted to site
   * administrators due to the sensitive nature of account-level restrictions.
   * Authentication failures should return 401 with the standard message, while
   * authorization failures should return 403. The operation is read-only and
   * does not modify any records.
   *
   * Error handling: if the provided restrictionId does not correspond to an
   * existing record, return an appropriate not-found response. This endpoint
   * complements PATCH /userRestrictions, which provides search capabilities
   * across many records.
   *
   * @param connection
   * @param restrictionId Target restriction’s UUID.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Get(":restrictionId")
  public async at(
    @SiteadminAuth()
    siteAdmin: SiteadminPayload,
    @TypedParam("restrictionId")
    restrictionId: string & tags.Format<"uuid">,
  ): Promise<ICommunityPlatformUserRestriction> {
    try {
      return await getCommunityPlatformSiteAdminUserRestrictionsRestrictionId({
        siteAdmin,
        restrictionId,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
