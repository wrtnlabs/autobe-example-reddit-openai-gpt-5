import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody } from "@nestia/core";
import typia from "typia";
import { patchCommunityPlatformSiteAdminUsers } from "../../../../providers/patchCommunityPlatformSiteAdminUsers";
import { SiteadminAuth } from "../../../../decorators/SiteadminAuth";
import { SiteadminPayload } from "../../../../decorators/payload/SiteadminPayload";

import { IPageICommunityPlatformUser } from "../../../../api/structures/IPageICommunityPlatformUser";
import { ICommunityPlatformUser } from "../../../../api/structures/ICommunityPlatformUser";

@Controller("/communityPlatform/siteAdmin/users")
export class CommunityplatformSiteadminUsersController {
  /**
   * Search and list accounts from community_platform_users with pagination and
   * sorting.
   *
   * Retrieve a filtered, sorted, and paginated list of user accounts stored in
   * the Prisma model community_platform_users. The underlying table includes id
   * (UUID), email, email_normalized, username, username_normalized,
   * password_hash, optional display_name, last_login_at, created_at,
   * updated_at, and optional deleted_at. Per the schema comments,
   * email_normalized and username_normalized enforce case-insensitive
   * uniqueness at the database layer; these are not user-facing fields but can
   * be used for exact/CI matches in search logic.
   *
   * Security and permissions: This operation is intended for administrative
   * back-office usage. Only authorized operators should be able to list
   * arbitrary accounts. The operation must never include password_hash or other
   * sensitive columns in the payload. Business logic may also mask portions of
   * email for privacy. Deleted accounts (deleted_at set) should be excluded by
   * default unless an explicit filter is provided for compliance views.
   *
   * Entity relationships: Users relate to role assignment tables
   * community_platform_registeredmembers (member state) and
   * community_platform_siteadmins (administrative state), to session records in
   * community_platform_sessions (long-lived sessions), and to content tables
   * (communities they created, posts, comments, votes). When producing
   * summaries, you can derive boolean flags like isMember or isSiteAdmin by
   * probing the existence of related role rows.
   *
   * Validation and business logic: Support free-text search over
   * username/display_name using trigram indices (as declared in Prisma indexes)
   * and optional exact/CI match on email/username via normalized columns.
   * Sorting typically includes created_at (Newest), last_login_at (recent
   * activity), or username ascending. Pagination follows cursor-based
   * continuation using the active sortâ€™s tiebreakers (e.g., created_at + id for
   * Newest). Respect minimal validation to keep flows smooth.
   *
   * Related operations: Use GET /users/{userId} to fetch a single account
   * detail. Use PUT /users/{userId} to update allowed profile fields (e.g.,
   * display_name, username/email with uniqueness checks). Use DELETE
   * /users/{userId} to deactivate an account (sets deleted_at) when policy
   * requires.
   *
   * Expected behavior and error handling: Return a stable page of up to 20
   * items by default with pageInfo.nextCursor when more data exists. Reject
   * unsupported sort values. Do not expose password_hash or normalized keys. If
   * a temporary error occurs, return a standardized transient error message.
   * Ownership rules do not apply to this admin-level index, so enforce
   * authorization globally.
   *
   * @param connection
   * @param body Search, filter, sort, and pagination parameters for user
   *   listing
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Patch()
  public async index(
    @SiteadminAuth()
    siteAdmin: SiteadminPayload,
    @TypedBody()
    body: ICommunityPlatformUser.IRequest,
  ): Promise<IPageICommunityPlatformUser.ISummary> {
    try {
      return await patchCommunityPlatformSiteAdminUsers({
        siteAdmin,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
