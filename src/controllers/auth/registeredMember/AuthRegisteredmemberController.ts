import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody } from "@nestia/core";
import typia from "typia";
import { postAuthRegisteredMemberJoin } from "../../../providers/postAuthRegisteredMemberJoin";
import { postAuthRegisteredMemberLogin } from "../../../providers/postAuthRegisteredMemberLogin";
import { postAuthRegisteredMemberRefresh } from "../../../providers/postAuthRegisteredMemberRefresh";
import { RegisteredmemberAuth } from "../../../decorators/RegisteredmemberAuth";
import { RegisteredmemberPayload } from "../../../decorators/payload/RegisteredmemberPayload";
import { postAuthRegisteredMemberLogout } from "../../../providers/postAuthRegisteredMemberLogout";
import { postAuthRegisteredMemberLogoutAll } from "../../../providers/postAuthRegisteredMemberLogoutAll";

import { ICommunityPlatformRegisteredMember } from "../../../api/structures/ICommunityPlatformRegisteredMember";

@Controller("/auth/registeredMember")
export class AuthRegisteredmemberController {
  /**
   * Register a new account in community_platform_users and grant member role
   * via community_platform_registeredmembers.
   *
   * This operation registers a new member account and issues initial
   * authorization tokens. It creates a row in community_platform_users,
   * populating email, email_normalized, username, username_normalized,
   * password_hash, and optionally display_name. The schema enforces
   * case-insensitive uniqueness through email_normalized and
   * username_normalized unique indexes, which the application must populate
   * from the provided human-readable values. The last_login_at timestamp may be
   * set at successful issuance time to support security analytics.
   *
   * Upon successful user creation, the operation assigns the member capability
   * by inserting into community_platform_registeredmembers using
   * community_platform_user_id, with registered_at set to the current
   * timestamp. The role assignment table serves as the canonical indicator that
   * the user is an active registered member and includes created_at and
   * updated_at for auditability.
   *
   * For session management aligned with long-lived sessions and
   * resume-after-login, the endpoint creates a record in
   * community_platform_sessions linked by community_platform_user_id. The
   * session record stores hashed_token (never plaintext), expires_at within the
   * absolute lifetime window, and can capture user_agent, ip, client_platform,
   * and client_device when provided. The record also maintains last_seen_at for
   * session renewal behavior and updated_at for audit.
   *
   * Security considerations follow the schema’s guidance that password_hash is
   * the only stored credential derivative and that normalized uniqueness must
   * be used for conflicts. The operation should return an authorization payload
   * enabling immediate authenticated actions consistent with member
   * permissions.
   *
   * Related operations include login for returning users and refresh for
   * renewing tokens. Clients typically call refresh in background to preserve
   * long sessions. Name and email normalization must be handled consistently so
   * that subsequent login comparisons can rely on email_normalized and
   * username_normalized.
   *
   * @param connection
   * @param body Registration payload for creating a member account.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("join")
  public async join(
    @TypedBody()
    body: ICommunityPlatformRegisteredMember.IJoin,
  ): Promise<ICommunityPlatformRegisteredMember.IAuthorized> {
    try {
      return await postAuthRegisteredMemberJoin({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Sign in a registered member and create a session in
   * community_platform_sessions.
   *
   * This operation signs in an existing registered member using an identifier
   * (email or username) and password. The system locates the account via the
   * normalized columns email_normalized or username_normalized as defined in
   * community_platform_users, then validates the supplied password against
   * password_hash. When credentials are valid and the account is a registered
   * member (row exists in community_platform_registeredmembers), a fresh
   * session is established.
   *
   * A new record in community_platform_sessions is created using
   * community_platform_user_id with a securely generated token hash in
   * hashed_token and an expires_at timestamp that respects the absolute
   * lifetime requirement. The session may also store user_agent and ip strings,
   * as well as client_platform or client_device when available. The
   * last_seen_at field can be initialized or updated to the current time to
   * facilitate idle-timeout renewal policies.
   *
   * The operation updates users.last_login_at upon successful authentication to
   * support security and analytics. Audit timestamps such as created_at and
   * updated_at are maintained by the application layer consistent with the
   * Prisma model definitions.
   *
   * From a security perspective, the endpoint never returns or stores plaintext
   * credentials or tokens; only token material suitable for client storage is
   * returned and only hashed_token is persisted server-side. The response
   * includes authorization details enabling posting, commenting, voting,
   * joining/leaving communities, and editing/deleting authored content,
   * consistent with the registered member role.
   *
   * Clients should use the refresh endpoint to renew sessions and maintain
   * long-lived access without user friction. If the user does not have a
   * corresponding row in community_platform_registeredmembers, the application
   * should deny sign-in for member scope or prompt the registration flow.
   *
   * @param connection
   * @param body Login credentials for member authentication.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("login")
  public async login(
    @TypedBody()
    body: ICommunityPlatformRegisteredMember.ILogin,
  ): Promise<ICommunityPlatformRegisteredMember.IAuthorized> {
    try {
      return await postAuthRegisteredMemberLogin({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Refresh a member session using community_platform_sessions as source of
   * truth.
   *
   * This operation renews a member session to support long-lived authentication
   * with resume-after-login behavior. The server validates the presented token
   * context against community_platform_sessions by comparing a hash with
   * hashed_token, verifying that expires_at has not passed and revoked_at is
   * null. When valid, the operation may rotate the client-facing token and
   * updates last_seen_at to reflect recent activity per long-session policy.
   *
   * The session remains linked to the account via community_platform_user_id,
   * enabling downstream permission checks consistent with the registered
   * member’s capabilities across posting, commenting, voting, community
   * creation, and join/leave actions. No credential re-entry is required when a
   * valid refresh token is provided.
   *
   * Security considerations include ensuring that only hashed_token is stored,
   * observing absolute lifetime constraints (expires_at), and recording
   * updated_at to reflect the modification. The endpoint’s response returns a
   * fresh authorization payload consistent with the member role.
   *
   * Related operations include login for initial credential authentication and
   * logout endpoints for revocation. If validation fails because the session is
   * expired or revoked, the application should require a full login.
   *
   * @param connection
   * @param body Refresh token or session renewal payload.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("refresh")
  public async refresh(
    @RegisteredmemberAuth()
    registeredMember: RegisteredmemberPayload,
    @TypedBody()
    body: ICommunityPlatformRegisteredMember.IRefresh,
  ): Promise<ICommunityPlatformRegisteredMember.IAuthorized> {
    try {
      return await postAuthRegisteredMemberRefresh({
        registeredMember,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Log out from the current session by revoking community_platform_sessions
   * record.
   *
   * This operation logs the member out from the current device by revoking the
   * active session. It targets the corresponding row in
   * community_platform_sessions associated with the authenticated
   * community_platform_user_id and marks it as revoked by setting revoked_at.
   * The record may also update updated_at and last_seen_at to reflect the
   * action.
   *
   * The users table community_platform_users is not modified for credential
   * data during logout; password_hash and identity fields remain unchanged.
   * This endpoint complements login and refresh by allowing users to explicitly
   * end a session while keeping reading access to public content.
   *
   * If the session is already revoked or expired (based on expires_at), the
   * system should treat the operation as idempotent and return success without
   * error to simplify client logic. Related operations include logoutAll to end
   * all sessions and revokeSession for targeted session management.
   *
   * @param connection
   * @param body Optional metadata for logout (e.g., client hints).
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("logout")
  public async logout(
    @RegisteredmemberAuth()
    registeredMember: RegisteredmemberPayload,
    @TypedBody()
    body: ICommunityPlatformRegisteredMember.ILogoutRequest,
  ): Promise<ICommunityPlatformRegisteredMember.ILogoutResult> {
    try {
      return await postAuthRegisteredMemberLogout({
        registeredMember,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Revoke all active sessions for the member in community_platform_sessions.
   *
   * This operation signs the member out of all devices by revoking every active
   * session linked to the account. It identifies sessions via
   * community_platform_user_id in community_platform_sessions and sets
   * revoked_at on each currently valid session. The action is idempotent;
   * repeating it after all sessions are already revoked produces no side
   * effects.
   *
   * No changes are made to credentials in community_platform_users such as
   * password_hash, and the role assignment in
   * community_platform_registeredmembers remains intact. This complements the
   * single-session logout and can be offered as a security control in profile
   * settings.
   *
   * If some sessions are already expired based on expires_at, they can be
   * included in the revocation sweep without error. Clients typically return to
   * read-only state after completion.
   *
   * @param connection
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("logoutAll")
  public async logoutAll(
    @RegisteredmemberAuth()
    registeredMember: RegisteredmemberPayload,
  ): Promise<ICommunityPlatformRegisteredMember.ILogoutAllResult> {
    try {
      return await postAuthRegisteredMemberLogoutAll({
        registeredMember,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
