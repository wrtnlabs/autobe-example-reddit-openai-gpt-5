import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody } from "@nestia/core";
import typia from "typia";
import { postauthSystemAdminJoin } from "../../../providers/postauthSystemAdminJoin";
import { postauthSystemAdminLogin } from "../../../providers/postauthSystemAdminLogin";
import { postauthSystemAdminRefresh } from "../../../providers/postauthSystemAdminRefresh";

import { ICommunityPlatformSystemAdmin } from "../../../api/structures/ICommunityPlatformSystemAdmin";

@Controller("/auth/systemAdmin")
export class AuthSystemadminController {
  /**
   * Register a new admin by creating community_platform_users,
   * community_platform_user_credentials, community_platform_systemadmins, and a
   * session in community_platform_sessions.
   *
   * Purpose and function: Registers a new platform administrator by creating
   * identity in community_platform_users, secure credentials in
   * community_platform_user_credentials, a role assignment in
   * community_platform_systemadmins, and an initial session in
   * community_platform_sessions. It returns signed tokens (access and refresh)
   * in ICommunityPlatformSystemAdmin.IAuthorized so the new admin can
   * immediately access admin-restricted features.
   *
   * Implementation details: The service validates uniqueness on
   * community_platform_users.username and
   * community_platform_user_credentials.email/email_normalized, persists
   * password_hash (never plaintext), initializes status, and records lifecycle
   * timestamps (created_at/updated_at). The admin role is established by
   * inserting into community_platform_systemadmins with granted_at and optional
   * granted_by_user_id when created by an existing admin. A refresh session is
   * inserted into community_platform_sessions including refresh_token_hash,
   * issued_at, expires_at, optional user_agent and ip. The response includes
   * JWTs corresponding to the newly created session.
   *
   * Role-specific integration: This endpoint specifically provisions the
   * "systemAdmin" capability tracked by community_platform_systemadmins,
   * enabling elevated policy enforcement separate from standard community
   * members. Ownership/authorship semantics remain unchanged; administrators do
   * not gain authorship over other usersâ€™ content per business rules.
   *
   * Security considerations: Passwords are accepted only to compute
   * password_hash stored in community_platform_user_credentials. Email
   * normalization populates email_normalized to enforce case-insensitive
   * uniqueness. The session layer stores refresh_token_hash only, never the raw
   * token, and uses issued_at/expires_at for lifecycle. last_login_at may be
   * updated on both users and credentials records after successful issuance.
   *
   * Related operations: After registration, administrators can authenticate
   * again via POST /auth/systemAdmin/login, renew tokens via POST
   * /auth/systemAdmin/refresh, change password via PUT
   * /auth/systemAdmin/password, and manage sessions via POST
   * /auth/systemAdmin/logout or /auth/systemAdmin/logoutAll.
   *
   * @param connection
   * @param body Registration payload for creating an admin account and initial
   *   session.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("join")
  public async join(
    @TypedBody()
    body: ICommunityPlatformSystemAdmin.ICreate,
  ): Promise<ICommunityPlatformSystemAdmin.IAuthorized> {
    try {
      return await postauthSystemAdminJoin({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Authenticate an admin via community_platform_user_credentials and issue a
   * session in community_platform_sessions.
   *
   * Purpose and function: Authenticates a platform administrator by validating
   * community_platform_user_credentials (email/email_normalized against
   * password_hash), confirming the user identity in community_platform_users,
   * and the admin role assignment in community_platform_systemadmins. On
   * success, it creates a new community_platform_sessions row and returns JWTs
   * in ICommunityPlatformSystemAdmin.IAuthorized.
   *
   * Implementation details: The service normalizes the email for lookup,
   * verifies the password against password_hash, checks user status, confirms
   * the admin role via community_platform_systemadmins, and writes a session
   * with refresh_token_hash, issued_at, expires_at, and optional user_agent/ip.
   * It updates last_login_at on both users and credentials.
   *
   * Role-specific integration: Only accounts with an active presence in
   * community_platform_systemadmins are considered systemAdmin and will receive
   * admin-scoped JWT claims. This preserves strong separation between standard
   * members and admins.
   *
   * Security considerations: Only token hashes are persisted in
   * community_platform_sessions, never raw tokens; access tokens are
   * short-lived while refresh tokens align with expires_at. The endpoint may
   * throttle by ip/user_agent from the request.
   *
   * Related operations: Use POST /auth/systemAdmin/refresh to renew tokens, PUT
   * /auth/systemAdmin/password to rotate password_hash and invalidate old
   * sessions per policy, and POST /auth/systemAdmin/logout or
   * /auth/systemAdmin/logoutAll to revoke sessions.
   *
   * @param connection
   * @param body Admin login credentials.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("login")
  public async login(
    @TypedBody()
    body: ICommunityPlatformSystemAdmin.ILogin,
  ): Promise<ICommunityPlatformSystemAdmin.IAuthorized> {
    try {
      return await postauthSystemAdminLogin({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Refresh admin tokens by validating community_platform_sessions and
   * confirming community_platform_systemadmins role.
   *
   * Purpose and function: Exchanges a valid refresh token for new JWTs for an
   * existing system administrator. It validates the underlying
   * community_platform_sessions row using refresh_token_hash and lifecycle
   * fields (issued_at, expires_at, revoked_at) and returns new tokens in
   * ICommunityPlatformSystemAdmin.IAuthorized.
   *
   * Implementation details: The service validates session currency and
   * optionally rotates refresh_token_hash and expires_at to extend the session,
   * persisting changes to updated_at. It confirms the user is still an admin
   * via community_platform_systemadmins.
   *
   * Role-specific integration: Ensures the caller maintains systemAdmin status
   * at refresh time; if the role was revoked (e.g., revoked_at set in
   * community_platform_systemadmins), refresh is denied.
   *
   * Security considerations: Only a hash of the refresh token is stored;
   * renewal should be refused if the session has revoked_at or has passed
   * expires_at. IP and user_agent may be compared to the stored values.
   *
   * Related operations: For explicit termination, use POST
   * /auth/systemAdmin/logout (current session) or POST
   * /auth/systemAdmin/logoutAll (all sessions). For password rotations, use PUT
   * /auth/systemAdmin/password to update password_hash and manage session
   * revocation per policy.
   *
   * @param connection
   * @param body Refresh token exchange payload.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("refresh")
  public async refresh(
    @TypedBody()
    body: ICommunityPlatformSystemAdmin.IRefresh,
  ): Promise<ICommunityPlatformSystemAdmin.IAuthorized> {
    try {
      return await postauthSystemAdminRefresh({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
