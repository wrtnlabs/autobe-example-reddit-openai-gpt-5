import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody } from "@nestia/core";
import typia from "typia";
import { postauthSystemAdminEmailVerify } from "../../../../../providers/postauthSystemAdminEmailVerify";

import { ICommunityPlatformSystemAdminEmailVerify } from "../../../../../api/structures/ICommunityPlatformSystemAdminEmailVerify";

@Controller("/auth/systemAdmin/email/verify")
export class AuthSystemadminEmailVerifyController {
  /**
   * Set email_verified_at on community_platform_user_credentials after
   * verifying the provided token.
   *
   * Purpose and function: Marks the admin’s email as verified by setting
   * email_verified_at on community_platform_user_credentials after validating
   * the provided verification token.
   *
   * Implementation details: The provider decodes/validates the token, locates
   * the relevant credentials record (email/email_normalized), and sets
   * email_verified_at. No changes are made to community_platform_users or
   * community_platform_sessions.
   *
   * Role-specific integration: Public confirmation does not require an
   * authenticated context because the token itself provides authorization for
   * this action; it pertains to a systemAdmin’s credentials record.
   *
   * Security considerations: Tokens must be single-use and time-limited; the
   * endpoint will refuse invalid or expired tokens and avoid leaking existence
   * of accounts beyond success/failure semantics.
   *
   * Related operations: If the user requires a new token, they should use POST
   * /auth/systemAdmin/email/verify/send after logging in.
   *
   * @param connection
   * @param body Verification token payload.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post()
  public async verifyEmail(
    @TypedBody()
    body: ICommunityPlatformSystemAdminEmailVerify.IRequest,
  ): Promise<ICommunityPlatformSystemAdminEmailVerify.IResponse> {
    try {
      return await postauthSystemAdminEmailVerify({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
