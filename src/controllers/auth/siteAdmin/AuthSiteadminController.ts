import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody } from "@nestia/core";
import typia from "typia";
import { postAuthSiteAdminJoin } from "../../../providers/postAuthSiteAdminJoin";
import { postAuthSiteAdminLogin } from "../../../providers/postAuthSiteAdminLogin";
import { postAuthSiteAdminRefresh } from "../../../providers/postAuthSiteAdminRefresh";
import { postAuthSiteAdminLogout } from "../../../providers/postAuthSiteAdminLogout";
import { SiteadminAuth } from "../../../decorators/SiteadminAuth";
import { SiteadminPayload } from "../../../decorators/payload/SiteadminPayload";
import { postAuthSiteAdminLogoutAll } from "../../../providers/postAuthSiteAdminLogoutAll";

import { ICommunityPlatformSiteAdmin } from "../../../api/structures/ICommunityPlatformSiteAdmin";
import { ICommunityPlatformSiteAdminJoin } from "../../../api/structures/ICommunityPlatformSiteAdminJoin";
import { ICommunityPlatformSiteAdminLogin } from "../../../api/structures/ICommunityPlatformSiteAdminLogin";
import { ICommunityPlatformSiteAdminRefresh } from "../../../api/structures/ICommunityPlatformSiteAdminRefresh";

@Controller("/auth/siteAdmin")
export class AuthSiteadminController {
  /**
   * Register a new admin account in community_platform_users and grant admin
   * via community_platform_siteadmins, issuing initial authorization.
   *
   * This endpoint registers a new platform administrator by inserting a user
   * record into the community_platform_users table and immediately granting
   * admin privileges through the community_platform_siteadmins table. The users
   * table contains email, email_normalized, username, username_normalized, and
   * password_hash columns that must be populated according to business rules.
   * The application is responsible for normalizing email and username into
   * email_normalized and username_normalized to satisfy the unique constraints,
   * and for hashing the password into password_hash before persistence.
   *
   * Upon successful creation, the system should also initialize a long-lived
   * session in the community_platform_sessions table. The session record
   * records hashed_token, created_at, last_seen_at, expires_at, and optionally
   * user_agent and ip to support the long-session experience and audit trails.
   * The user record’s last_login_at should be updated to the current time to
   * reflect an initial sign-in at registration when auto-login is enabled.
   *
   * This operation is intended for establishing an administrator (siteAdmin)
   * role using the community_platform_siteadmins table by inserting a row with
   * community_platform_user_id and granted_at. The unique index across
   * community_platform_siteadmins ensures one admin grant per user.
   *
   * Security considerations include: creating password_hash from a plaintext
   * password, not storing plaintext secrets, and enforcing uniqueness via
   * email_normalized/username_normalized. The users model also provides
   * deleted_at for deactivation scenarios, which should be honored by
   * downstream systems, but this endpoint does not manipulate that field.
   *
   * This endpoint is typically followed by the token/session refresh endpoint
   * for extending session lifetime and by sign-out endpoints that revoke
   * sessions via community_platform_sessions.revoked_at. Errors include
   * uniqueness violations based on email_normalized or username_normalized and
   * general validation failures tied to required fields.
   *
   * @param connection
   * @param body New admin registration payload with identifier and password
   *   information.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("join")
  public async join(
    @TypedBody()
    body: ICommunityPlatformSiteAdminJoin.ICreate,
  ): Promise<ICommunityPlatformSiteAdmin.IAuthorized> {
    try {
      return await postAuthSiteAdminJoin({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Authenticate admin via community_platform_users and create a session in
   * community_platform_sessions, returning authorized admin info.
   *
   * This endpoint authenticates a platform administrator using the credentials
   * stored in community_platform_users. The table provides
   * email/email_normalized and username/username_normalized pairs to support
   * case-insensitive lookup by either identifier. The provided password is
   * verified against password_hash; if valid, a new session is persisted in
   * community_platform_sessions with hashed_token, created_at, expires_at, and
   * optional user_agent/ip metadata. On success, last_login_at in
   * community_platform_users is updated.
   *
   * The response returns an authorized representation for the SiteAdmin role,
   * enabling long-lived sessions per business requirements. Session lifecycle
   * is governed by community_platform_sessions.expires_at and may later be
   * extended through the refresh operation. The system should ensure that any
   * user flagged as an administrator has a row in community_platform_siteadmins
   * for authorization decisions.
   *
   * Security considerations include strictly comparing the hashed credential,
   * never returning password_hash, and ensuring that deleted_at in
   * community_platform_users is respected by rejecting logins for deactivated
   * accounts. Additionally, use of email_normalized/username_normalized
   * prevents case-based duplication.
   *
   * This operation is commonly used in conjunction with /auth/siteAdmin/refresh
   * to maintain the long-session experience, and with /auth/siteAdmin/logout or
   * /auth/siteAdmin/logoutAll to revoke sessions by setting
   * community_platform_sessions.revoked_at.
   *
   * @param connection
   * @param body Admin login payload containing identifier and password.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("login")
  public async login(
    @TypedBody()
    body: ICommunityPlatformSiteAdminLogin.ICreate,
  ): Promise<ICommunityPlatformSiteAdmin.IAuthorized> {
    try {
      return await postAuthSiteAdminLogin({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Refresh an admin’s session using community_platform_sessions to issue
   * renewed authorization.
   *
   * This endpoint refreshes the administrator’s session, extending the
   * long-lived experience mandated by the product requirements. It validates
   * the current session using the community_platform_sessions table, ensuring
   * that revoked_at is null and expires_at has not lapsed. On success, the
   * system may rotate tokens and update last_seen_at and possibly expires_at to
   * renew the idle timeout window.
   *
   * The user identity remains sourced from community_platform_users, which
   * includes last_login_at for analytics and audit. While this endpoint does
   * not alter the user’s password_hash, it must ensure the associated user is
   * still eligible for access (e.g., no deactivation indicated via deleted_at).
   * If required by policy, it can also verify the presence of an admin grant in
   * community_platform_siteadmins for the user.
   *
   * Security considerations include avoiding disclosure of hashed_token and
   * never persisting plaintext secrets. The refresh process should be
   * idempotent per session token and comply with the absolute lifetime
   * boundaries represented by community_platform_sessions.expires_at. The
   * system may update last_seen_at in community_platform_sessions to reflect
   * activity.
   *
   * This operation is typically paired with /auth/siteAdmin/login and
   * /auth/siteAdmin/join to establish sessions initially, and with
   * /auth/siteAdmin/logout or /auth/siteAdmin/logoutAll to end sessions by
   * setting revoked_at.
   *
   * @param connection
   * @param body Refresh request containing data needed to validate and renew
   *   the session.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("refresh")
  public async refresh(
    @TypedBody()
    body: ICommunityPlatformSiteAdminRefresh.IRequest,
  ): Promise<ICommunityPlatformSiteAdmin.IAuthorized> {
    try {
      return await postAuthSiteAdminRefresh({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Revoke the current admin session by setting revoked_at in
   * community_platform_sessions.
   *
   * This endpoint logs out the current administrator by revoking the in-use
   * session in the community_platform_sessions table. The session record
   * includes hashed_token, created_at, last_seen_at, expires_at, and
   * revoked_at. Setting revoked_at indicates that the session is no longer
   * valid for future requests. This operation does not delete user records in
   * community_platform_users nor modify password_hash.
   *
   * The endpoint requires an authenticated SiteAdmin context. It targets only
   * the currently authenticated session, leaving any other sessions for the
   * same user intact. It complements the long-lived session model by enabling
   * explicit termination, and pairs with /auth/siteAdmin/logoutAll for broader
   * revocation across devices.
   *
   * Error behavior should handle cases where the session is already revoked or
   * missing, updating idempotently. The users table includes last_login_at and
   * deleted_at for audit and deactivation semantics respectively; those fields
   * are not changed by this operation.
   *
   * @param connection
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("logout")
  public async logout(
    @SiteadminAuth()
    siteAdmin: SiteadminPayload,
  ): Promise<void> {
    try {
      return await postAuthSiteAdminLogout({
        siteAdmin,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Revoke all admin sessions by updating revoked_at for all of the user’s
   * community_platform_sessions.
   *
   * This endpoint logs the administrator out of all devices by revoking every
   * active session found in the community_platform_sessions table for the
   * current user. For each session, revoked_at is set to the current time,
   * rendering the session unusable. This operation does not delete the user’s
   * account in community_platform_users nor alter password_hash.
   *
   * The users table fields updated_at and last_login_at are unaffected directly
   * by this endpoint. The action is auditable using session timestamps
   * (created_at, last_seen_at) and can be combined with security UIs that list
   * sessions by device (user_agent, ip, client_platform) before revocation.
   *
   * Related operations include /auth/siteAdmin/logout for single-session
   * termination, /auth/siteAdmin/login for subsequent sign-in, and
   * /auth/siteAdmin/refresh to re-establish a session after revocation.
   *
   * @param connection
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("logoutAll")
  public async logoutAll(
    @SiteadminAuth()
    siteAdmin: SiteadminPayload,
  ): Promise<void> {
    try {
      return await postAuthSiteAdminLogoutAll({
        siteAdmin,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
