import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformSystemAdmin } from "../../../structures/ICommunityPlatformSystemAdmin";
export * as logout from "./logout/index";
export * as logoutAll from "./logoutAll/index";
export * as password from "./password/index";
export * as email from "./email/index";

/**
 * Register a new admin by creating community_platform_users,
 * community_platform_user_credentials, community_platform_systemadmins, and a
 * session in community_platform_sessions.
 *
 * Purpose and function: Registers a new platform administrator by creating
 * identity in community_platform_users, secure credentials in
 * community_platform_user_credentials, a role assignment in
 * community_platform_systemadmins, and an initial session in
 * community_platform_sessions. It returns signed tokens (access and refresh) in
 * ICommunityPlatformSystemAdmin.IAuthorized so the new admin can immediately
 * access admin-restricted features.
 *
 * Implementation details: The service validates uniqueness on
 * community_platform_users.username and
 * community_platform_user_credentials.email/email_normalized, persists
 * password_hash (never plaintext), initializes status, and records lifecycle
 * timestamps (created_at/updated_at). The admin role is established by
 * inserting into community_platform_systemadmins with granted_at and optional
 * granted_by_user_id when created by an existing admin. A refresh session is
 * inserted into community_platform_sessions including refresh_token_hash,
 * issued_at, expires_at, optional user_agent and ip. The response includes JWTs
 * corresponding to the newly created session.
 *
 * Role-specific integration: This endpoint specifically provisions the
 * "systemAdmin" capability tracked by community_platform_systemadmins, enabling
 * elevated policy enforcement separate from standard community members.
 * Ownership/authorship semantics remain unchanged; administrators do not gain
 * authorship over other usersâ€™ content per business rules.
 *
 * Security considerations: Passwords are accepted only to compute password_hash
 * stored in community_platform_user_credentials. Email normalization populates
 * email_normalized to enforce case-insensitive uniqueness. The session layer
 * stores refresh_token_hash only, never the raw token, and uses
 * issued_at/expires_at for lifecycle. last_login_at may be updated on both
 * users and credentials records after successful issuance.
 *
 * Related operations: After registration, administrators can authenticate again
 * via POST /auth/systemAdmin/login, renew tokens via POST
 * /auth/systemAdmin/refresh, change password via PUT
 * /auth/systemAdmin/password, and manage sessions via POST
 * /auth/systemAdmin/logout or /auth/systemAdmin/logoutAll.
 *
 * @param props.connection
 * @param props.body Registration payload for creating an admin account and
 *   initial session.
 * @setHeader token.access Authorization
 *
 * @path /auth/systemAdmin/join
 * @accessor api.functional.auth.systemAdmin.join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /**
     * Registration payload for creating an admin account and initial
     * session.
     */
    body: ICommunityPlatformSystemAdmin.ICreate;
  };
  export type Body = ICommunityPlatformSystemAdmin.ICreate;
  export type Response = ICommunityPlatformSystemAdmin.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/systemAdmin/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/systemAdmin/join";
  export const random = (): ICommunityPlatformSystemAdmin.IAuthorized =>
    typia.random<ICommunityPlatformSystemAdmin.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Authenticate an admin via community_platform_user_credentials and issue a
 * session in community_platform_sessions.
 *
 * Purpose and function: Authenticates a platform administrator by validating
 * community_platform_user_credentials (email/email_normalized against
 * password_hash), confirming the user identity in community_platform_users, and
 * the admin role assignment in community_platform_systemadmins. On success, it
 * creates a new community_platform_sessions row and returns JWTs in
 * ICommunityPlatformSystemAdmin.IAuthorized.
 *
 * Implementation details: The service normalizes the email for lookup, verifies
 * the password against password_hash, checks user status, confirms the admin
 * role via community_platform_systemadmins, and writes a session with
 * refresh_token_hash, issued_at, expires_at, and optional user_agent/ip. It
 * updates last_login_at on both users and credentials.
 *
 * Role-specific integration: Only accounts with an active presence in
 * community_platform_systemadmins are considered systemAdmin and will receive
 * admin-scoped JWT claims. This preserves strong separation between standard
 * members and admins.
 *
 * Security considerations: Only token hashes are persisted in
 * community_platform_sessions, never raw tokens; access tokens are short-lived
 * while refresh tokens align with expires_at. The endpoint may throttle by
 * ip/user_agent from the request.
 *
 * Related operations: Use POST /auth/systemAdmin/refresh to renew tokens, PUT
 * /auth/systemAdmin/password to rotate password_hash and invalidate old
 * sessions per policy, and POST /auth/systemAdmin/logout or
 * /auth/systemAdmin/logoutAll to revoke sessions.
 *
 * @param props.connection
 * @param props.body Admin login credentials.
 * @setHeader token.access Authorization
 *
 * @path /auth/systemAdmin/login
 * @accessor api.functional.auth.systemAdmin.login
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function login(
  connection: IConnection,
  props: login.Props,
): Promise<login.Response> {
  const output: login.Response =
    true === connection.simulate
      ? login.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...login.METADATA,
            path: login.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace login {
  export type Props = {
    /** Admin login credentials. */
    body: ICommunityPlatformSystemAdmin.ILogin;
  };
  export type Body = ICommunityPlatformSystemAdmin.ILogin;
  export type Response = ICommunityPlatformSystemAdmin.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/systemAdmin/login",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/systemAdmin/login";
  export const random = (): ICommunityPlatformSystemAdmin.IAuthorized =>
    typia.random<ICommunityPlatformSystemAdmin.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: login.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: login.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Refresh admin tokens by validating community_platform_sessions and confirming
 * community_platform_systemadmins role.
 *
 * Purpose and function: Exchanges a valid refresh token for new JWTs for an
 * existing system administrator. It validates the underlying
 * community_platform_sessions row using refresh_token_hash and lifecycle fields
 * (issued_at, expires_at, revoked_at) and returns new tokens in
 * ICommunityPlatformSystemAdmin.IAuthorized.
 *
 * Implementation details: The service validates session currency and optionally
 * rotates refresh_token_hash and expires_at to extend the session, persisting
 * changes to updated_at. It confirms the user is still an admin via
 * community_platform_systemadmins.
 *
 * Role-specific integration: Ensures the caller maintains systemAdmin status at
 * refresh time; if the role was revoked (e.g., revoked_at set in
 * community_platform_systemadmins), refresh is denied.
 *
 * Security considerations: Only a hash of the refresh token is stored; renewal
 * should be refused if the session has revoked_at or has passed expires_at. IP
 * and user_agent may be compared to the stored values.
 *
 * Related operations: For explicit termination, use POST
 * /auth/systemAdmin/logout (current session) or POST
 * /auth/systemAdmin/logoutAll (all sessions). For password rotations, use PUT
 * /auth/systemAdmin/password to update password_hash and manage session
 * revocation per policy.
 *
 * @param props.connection
 * @param props.body Refresh token exchange payload.
 * @setHeader token.access Authorization
 *
 * @path /auth/systemAdmin/refresh
 * @accessor api.functional.auth.systemAdmin.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /** Refresh token exchange payload. */
    body: ICommunityPlatformSystemAdmin.IRefresh;
  };
  export type Body = ICommunityPlatformSystemAdmin.IRefresh;
  export type Response = ICommunityPlatformSystemAdmin.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/systemAdmin/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/systemAdmin/refresh";
  export const random = (): ICommunityPlatformSystemAdmin.IAuthorized =>
    typia.random<ICommunityPlatformSystemAdmin.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
