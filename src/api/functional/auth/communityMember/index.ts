import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformCommunityMember } from "../../../structures/ICommunityPlatformCommunityMember";
export * as password from "./password/index";

/**
 * Register a communityMember using community_platform_users,
 * community_platform_user_credentials, community_platform_communitymembers, and
 * community_platform_sessions.
 *
 * This endpoint registers a new community member by creating records across the
 * Actors schema. It first inserts a backbone identity into
 * community_platform_users (fields: id, username, status, created_at,
 * updated_at), ensuring username uniqueness per @@unique([username]). It then
 * persists credentials in community_platform_user_credentials using email and
 * email_normalized, with the password stored as password_hash and timestamps
 * managed in created_at/updated_at. If verification policies apply,
 * email_verified_at remains null until separately verified; this field is
 * referenced for later flows but not required here.
 *
 * After successfully creating user and credential records, the operation
 * assigns the role in community_platform_communitymembers by inserting a row
 * with community_platform_user_id, status (e.g., active), and since_at,
 * aligning with the role taxonomy for authenticated users. This assignment
 * enables permission checks that differentiate communityMember from other roles
 * such as systemAdmin.
 *
 * To enable session continuity and refresh-token rotation, the endpoint creates
 * a session in community_platform_sessions with refresh_token_hash, issued_at,
 * expires_at, optional user_agent and ip, and revoked_at initially null. The
 * session record is used for token renewal and sign-out behaviors. Unique
 * constraint @@unique([refresh_token_hash]) ensures token uniqueness.
 *
 * Security considerations include hashing user passwords into
 * community_platform_user_credentials.password_hash and never storing
 * plaintext. The flow respects indexes and uniqueness on
 * community_platform_user_credentials.email and
 * community_platform_user_credentials.email_normalized to enforce email
 * uniqueness. The response returns an access token and a refresh token (backed
 * by community_platform_sessions) within
 * ICommunityPlatformCommunityMember.IAuthorized.
 *
 * Related operations: POST /auth/communityMember/login authenticates existing
 * accounts using community_platform_user_credentials; POST
 * /auth/communityMember/refresh uses community_platform_sessions to renew
 * tokens. These operations together complete the authentication lifecycle for
 * communityMember.
 *
 * @param props.connection
 * @param props.body Registration payload including username, email, and
 *   password.
 * @setHeader token.access Authorization
 *
 * @path /auth/communityMember/join
 * @accessor api.functional.auth.communityMember.join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /** Registration payload including username, email, and password. */
    body: ICommunityPlatformCommunityMember.ICreate;
  };
  export type Body = ICommunityPlatformCommunityMember.ICreate;
  export type Response = ICommunityPlatformCommunityMember.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/communityMember/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/communityMember/join";
  export const random = (): ICommunityPlatformCommunityMember.IAuthorized =>
    typia.random<ICommunityPlatformCommunityMember.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Authenticate a communityMember using community_platform_user_credentials and
 * issue a session in community_platform_sessions.
 *
 * This endpoint authenticates a community member by validating user credentials
 * stored in community_platform_user_credentials. The request identifies the
 * account using either email (matched against email_normalized) or username via
 * community_platform_users.username and then retrieves the associated
 * community_platform_user_credentials.password_hash for secure comparison. On
 * success, the system updates last_login_at in both
 * community_platform_user_credentials and community_platform_users to reflect
 * the successful authentication event.
 *
 * A new session row is created in community_platform_sessions containing
 * refresh_token_hash (hashed), issued_at, expires_at, and optional
 * user_agent/ip context for audit. The session’s revoked_at remains null to
 * indicate an active session. Uniqueness on refresh_token_hash prevents
 * duplication and facilitates revocation and rotation.
 *
 * The operation is aligned with the role assignment in
 * community_platform_communitymembers, which marks that the authenticated user
 * is a member (status and since_at maintained there). While this endpoint does
 * not modify community_platform_communitymembers, its presence is implied for
 * permission checks in subsequent guarded actions.
 *
 * Security considerations include strict use of password_hash and never storing
 * plaintext passwords. On successful authentication, an access token and a
 * refresh token are issued, and the response conforms to
 * ICommunityPlatformCommunityMember.IAuthorized. The access token is
 * short-lived; the refresh token corresponds to the community_platform_sessions
 * row.
 *
 * Related operations: POST /auth/communityMember/join creates the underlying
 * records for new users, and POST /auth/communityMember/refresh renews tokens
 * using existing community_platform_sessions entries. POST
 * /auth/communityMember/logout and POST /auth/communityMember/logoutAll manage
 * session revocation via the same table.
 *
 * @param props.connection
 * @param props.body Login payload with identifier (email or username) and
 *   password.
 * @setHeader token.access Authorization
 *
 * @path /auth/communityMember/login
 * @accessor api.functional.auth.communityMember.login
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function login(
  connection: IConnection,
  props: login.Props,
): Promise<login.Response> {
  const output: login.Response =
    true === connection.simulate
      ? login.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...login.METADATA,
            path: login.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace login {
  export type Props = {
    /** Login payload with identifier (email or username) and password. */
    body: ICommunityPlatformCommunityMember.ILogin;
  };
  export type Body = ICommunityPlatformCommunityMember.ILogin;
  export type Response = ICommunityPlatformCommunityMember.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/communityMember/login",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/communityMember/login";
  export const random = (): ICommunityPlatformCommunityMember.IAuthorized =>
    typia.random<ICommunityPlatformCommunityMember.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: login.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: login.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Refresh tokens for communityMember by validating community_platform_sessions.
 *
 * This endpoint renews access tokens for a community member using the persisted
 * session in community_platform_sessions. The provided refresh token is hashed
 * and matched against refresh_token_hash with checks that revoked_at is null
 * and expires_at has not passed. On success, the server may rotate the refresh
 * token by updating the associated session’s refresh_token_hash and updated_at
 * while preserving issued_at/expires_at semantics according to policy.
 *
 * Because community_platform_sessions links to community_platform_users via
 * community_platform_user_id, the refreshed authorization reflects the same
 * member identity. This process does not modify
 * community_platform_communitymembers; it relies on that table’s presence for
 * permission checks elsewhere.
 *
 * Security considerations include rejecting tokens for sessions where
 * revoked_at is set or expires_at has elapsed. The response returns a new
 * access token and, if rotated, a new refresh token, within
 * ICommunityPlatformCommunityMember.IAuthorized. No profile fields are returned
 * from community_platform_user_profiles here; the focus is strictly on session
 * renewal and JWT issuance.
 *
 * Related operations: POST /auth/communityMember/login establishes the session;
 * POST /auth/communityMember/logout and POST /auth/communityMember/logoutAll
 * revoke sessions by setting revoked_at; POST /auth/communityMember/join is
 * used to provision initial accounts and sessions.
 *
 * @param props.connection
 * @param props.body Refresh token payload.
 * @setHeader token.access Authorization
 *
 * @path /auth/communityMember/refresh
 * @accessor api.functional.auth.communityMember.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /** Refresh token payload. */
    body: ICommunityPlatformCommunityMember.IRefresh;
  };
  export type Body = ICommunityPlatformCommunityMember.IRefresh;
  export type Response = ICommunityPlatformCommunityMember.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/communityMember/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/communityMember/refresh";
  export const random = (): ICommunityPlatformCommunityMember.IAuthorized =>
    typia.random<ICommunityPlatformCommunityMember.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Revoke current communityMember session using
 * community_platform_sessions.revoked_at.
 *
 * This endpoint revokes the current authenticated session by updating the
 * corresponding row in community_platform_sessions: setting revoked_at (and
 * updated_at) to mark the refresh token unusable. The session row is linked to
 * the actor via community_platform_user_id and may record user_agent/ip as
 * originally issued. After revocation, subsequent token refresh attempts using
 * the same refresh_token_hash must fail.
 *
 * Security considerations: Only the authenticated community member may revoke
 * their own active session. This does not impact other active sessions for the
 * same user. The operation intentionally returns no body; clients should clear
 * local credentials upon success.
 *
 * Related operations: POST /auth/communityMember/logoutAll revokes all sessions
 * for the user by setting revoked_at on each matching row; POST
 * /auth/communityMember/refresh validates non-revoked sessions (revoked_at
 * null) prior to issuing new tokens.
 *
 * @param props.connection
 * @path /auth/communityMember/logout
 * @accessor api.functional.auth.communityMember.logout
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function logout(connection: IConnection): Promise<void> {
  return true === connection.simulate
    ? logout.simulate(connection)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...logout.METADATA,
          path: logout.path(),
          status: null,
        },
      );
}
export namespace logout {
  export const METADATA = {
    method: "POST",
    path: "/auth/communityMember/logout",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/communityMember/logout";
  export const random = (): void => typia.random<void>();
  export const simulate = (_connection: IConnection): void => {
    return random();
  };
}

/**
 * Revoke all communityMember sessions by updating
 * community_platform_sessions.revoked_at for the user.
 *
 * This endpoint signs the user out from all devices by setting revoked_at
 * across all rows in community_platform_sessions for the authenticated user
 * (identified via community_platform_user_id). After completion, no prior
 * refresh_token_hash remains valid for token renewal.
 *
 * Security considerations: The action affects every active session for the user
 * account, ensuring a complete sign-out. Clients should clear local tokens. New
 * sessions may be established later via POST /auth/communityMember/login.
 *
 * Related operations: POST /auth/communityMember/logout revokes only the
 * current session; POST /auth/communityMember/refresh continues to work only
 * for sessions where revoked_at remains null and expires_at is valid.
 *
 * @param props.connection
 * @path /auth/communityMember/logoutAll
 * @accessor api.functional.auth.communityMember.logoutAll
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function logoutAll(connection: IConnection): Promise<void> {
  return true === connection.simulate
    ? logoutAll.simulate(connection)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...logoutAll.METADATA,
          path: logoutAll.path(),
          status: null,
        },
      );
}
export namespace logoutAll {
  export const METADATA = {
    method: "POST",
    path: "/auth/communityMember/logoutAll",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/communityMember/logoutAll";
  export const random = (): void => typia.random<void>();
  export const simulate = (_connection: IConnection): void => {
    return random();
  };
}
