import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformSiteAdminJoin } from "../../../structures/ICommunityPlatformSiteAdminJoin";
import { ICommunityPlatformSiteAdmin } from "../../../structures/ICommunityPlatformSiteAdmin";
import { ICommunityPlatformSiteAdminLogin } from "../../../structures/ICommunityPlatformSiteAdminLogin";
import { ICommunityPlatformSiteAdminRefresh } from "../../../structures/ICommunityPlatformSiteAdminRefresh";
export * as password from "./password/index";

/**
 * Register a new admin account in community_platform_users and grant admin via
 * community_platform_siteadmins, issuing initial authorization.
 *
 * This endpoint registers a new platform administrator by inserting a user
 * record into the community_platform_users table and immediately granting admin
 * privileges through the community_platform_siteadmins table. The users table
 * contains email, email_normalized, username, username_normalized, and
 * password_hash columns that must be populated according to business rules. The
 * application is responsible for normalizing email and username into
 * email_normalized and username_normalized to satisfy the unique constraints,
 * and for hashing the password into password_hash before persistence.
 *
 * Upon successful creation, the system should also initialize a long-lived
 * session in the community_platform_sessions table. The session record records
 * hashed_token, created_at, last_seen_at, expires_at, and optionally user_agent
 * and ip to support the long-session experience and audit trails. The user
 * record’s last_login_at should be updated to the current time to reflect an
 * initial sign-in at registration when auto-login is enabled.
 *
 * This operation is intended for establishing an administrator (siteAdmin) role
 * using the community_platform_siteadmins table by inserting a row with
 * community_platform_user_id and granted_at. The unique index across
 * community_platform_siteadmins ensures one admin grant per user.
 *
 * Security considerations include: creating password_hash from a plaintext
 * password, not storing plaintext secrets, and enforcing uniqueness via
 * email_normalized/username_normalized. The users model also provides
 * deleted_at for deactivation scenarios, which should be honored by downstream
 * systems, but this endpoint does not manipulate that field.
 *
 * This endpoint is typically followed by the token/session refresh endpoint for
 * extending session lifetime and by sign-out endpoints that revoke sessions via
 * community_platform_sessions.revoked_at. Errors include uniqueness violations
 * based on email_normalized or username_normalized and general validation
 * failures tied to required fields.
 *
 * @param props.connection
 * @param props.body New admin registration payload with identifier and password
 *   information.
 * @setHeader token.access Authorization
 *
 * @path /auth/siteAdmin/join
 * @accessor api.functional.auth.siteAdmin.join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /**
     * New admin registration payload with identifier and password
     * information.
     */
    body: ICommunityPlatformSiteAdminJoin.ICreate;
  };
  export type Body = ICommunityPlatformSiteAdminJoin.ICreate;
  export type Response = ICommunityPlatformSiteAdmin.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/siteAdmin/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/siteAdmin/join";
  export const random = (): ICommunityPlatformSiteAdmin.IAuthorized =>
    typia.random<ICommunityPlatformSiteAdmin.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Authenticate admin via community_platform_users and create a session in
 * community_platform_sessions, returning authorized admin info.
 *
 * This endpoint authenticates a platform administrator using the credentials
 * stored in community_platform_users. The table provides email/email_normalized
 * and username/username_normalized pairs to support case-insensitive lookup by
 * either identifier. The provided password is verified against password_hash;
 * if valid, a new session is persisted in community_platform_sessions with
 * hashed_token, created_at, expires_at, and optional user_agent/ip metadata. On
 * success, last_login_at in community_platform_users is updated.
 *
 * The response returns an authorized representation for the SiteAdmin role,
 * enabling long-lived sessions per business requirements. Session lifecycle is
 * governed by community_platform_sessions.expires_at and may later be extended
 * through the refresh operation. The system should ensure that any user flagged
 * as an administrator has a row in community_platform_siteadmins for
 * authorization decisions.
 *
 * Security considerations include strictly comparing the hashed credential,
 * never returning password_hash, and ensuring that deleted_at in
 * community_platform_users is respected by rejecting logins for deactivated
 * accounts. Additionally, use of email_normalized/username_normalized prevents
 * case-based duplication.
 *
 * This operation is commonly used in conjunction with /auth/siteAdmin/refresh
 * to maintain the long-session experience, and with /auth/siteAdmin/logout or
 * /auth/siteAdmin/logoutAll to revoke sessions by setting
 * community_platform_sessions.revoked_at.
 *
 * @param props.connection
 * @param props.body Admin login payload containing identifier and password.
 * @setHeader token.access Authorization
 *
 * @path /auth/siteAdmin/login
 * @accessor api.functional.auth.siteAdmin.login
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function login(
  connection: IConnection,
  props: login.Props,
): Promise<login.Response> {
  const output: login.Response =
    true === connection.simulate
      ? login.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...login.METADATA,
            path: login.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace login {
  export type Props = {
    /** Admin login payload containing identifier and password. */
    body: ICommunityPlatformSiteAdminLogin.ICreate;
  };
  export type Body = ICommunityPlatformSiteAdminLogin.ICreate;
  export type Response = ICommunityPlatformSiteAdmin.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/siteAdmin/login",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/siteAdmin/login";
  export const random = (): ICommunityPlatformSiteAdmin.IAuthorized =>
    typia.random<ICommunityPlatformSiteAdmin.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: login.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: login.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Refresh an admin’s session using community_platform_sessions to issue renewed
 * authorization.
 *
 * This endpoint refreshes the administrator’s session, extending the long-lived
 * experience mandated by the product requirements. It validates the current
 * session using the community_platform_sessions table, ensuring that revoked_at
 * is null and expires_at has not lapsed. On success, the system may rotate
 * tokens and update last_seen_at and possibly expires_at to renew the idle
 * timeout window.
 *
 * The user identity remains sourced from community_platform_users, which
 * includes last_login_at for analytics and audit. While this endpoint does not
 * alter the user’s password_hash, it must ensure the associated user is still
 * eligible for access (e.g., no deactivation indicated via deleted_at). If
 * required by policy, it can also verify the presence of an admin grant in
 * community_platform_siteadmins for the user.
 *
 * Security considerations include avoiding disclosure of hashed_token and never
 * persisting plaintext secrets. The refresh process should be idempotent per
 * session token and comply with the absolute lifetime boundaries represented by
 * community_platform_sessions.expires_at. The system may update last_seen_at in
 * community_platform_sessions to reflect activity.
 *
 * This operation is typically paired with /auth/siteAdmin/login and
 * /auth/siteAdmin/join to establish sessions initially, and with
 * /auth/siteAdmin/logout or /auth/siteAdmin/logoutAll to end sessions by
 * setting revoked_at.
 *
 * @param props.connection
 * @param props.body Refresh request containing data needed to validate and
 *   renew the session.
 * @setHeader token.access Authorization
 *
 * @path /auth/siteAdmin/refresh
 * @accessor api.functional.auth.siteAdmin.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /**
     * Refresh request containing data needed to validate and renew the
     * session.
     */
    body: ICommunityPlatformSiteAdminRefresh.IRequest;
  };
  export type Body = ICommunityPlatformSiteAdminRefresh.IRequest;
  export type Response = ICommunityPlatformSiteAdmin.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/siteAdmin/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/siteAdmin/refresh";
  export const random = (): ICommunityPlatformSiteAdmin.IAuthorized =>
    typia.random<ICommunityPlatformSiteAdmin.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Revoke the current admin session by setting revoked_at in
 * community_platform_sessions.
 *
 * This endpoint logs out the current administrator by revoking the in-use
 * session in the community_platform_sessions table. The session record includes
 * hashed_token, created_at, last_seen_at, expires_at, and revoked_at. Setting
 * revoked_at indicates that the session is no longer valid for future requests.
 * This operation does not delete user records in community_platform_users nor
 * modify password_hash.
 *
 * The endpoint requires an authenticated SiteAdmin context. It targets only the
 * currently authenticated session, leaving any other sessions for the same user
 * intact. It complements the long-lived session model by enabling explicit
 * termination, and pairs with /auth/siteAdmin/logoutAll for broader revocation
 * across devices.
 *
 * Error behavior should handle cases where the session is already revoked or
 * missing, updating idempotently. The users table includes last_login_at and
 * deleted_at for audit and deactivation semantics respectively; those fields
 * are not changed by this operation.
 *
 * @param props.connection
 * @path /auth/siteAdmin/logout
 * @accessor api.functional.auth.siteAdmin.logout
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function logout(connection: IConnection): Promise<void> {
  return true === connection.simulate
    ? logout.simulate(connection)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...logout.METADATA,
          path: logout.path(),
          status: null,
        },
      );
}
export namespace logout {
  export const METADATA = {
    method: "POST",
    path: "/auth/siteAdmin/logout",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/siteAdmin/logout";
  export const random = (): void => typia.random<void>();
  export const simulate = (_connection: IConnection): void => {
    return random();
  };
}

/**
 * Revoke all admin sessions by updating revoked_at for all of the user’s
 * community_platform_sessions.
 *
 * This endpoint logs the administrator out of all devices by revoking every
 * active session found in the community_platform_sessions table for the current
 * user. For each session, revoked_at is set to the current time, rendering the
 * session unusable. This operation does not delete the user’s account in
 * community_platform_users nor alter password_hash.
 *
 * The users table fields updated_at and last_login_at are unaffected directly
 * by this endpoint. The action is auditable using session timestamps
 * (created_at, last_seen_at) and can be combined with security UIs that list
 * sessions by device (user_agent, ip, client_platform) before revocation.
 *
 * Related operations include /auth/siteAdmin/logout for single-session
 * termination, /auth/siteAdmin/login for subsequent sign-in, and
 * /auth/siteAdmin/refresh to re-establish a session after revocation.
 *
 * @param props.connection
 * @path /auth/siteAdmin/logoutAll
 * @accessor api.functional.auth.siteAdmin.logoutAll
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function logoutAll(connection: IConnection): Promise<void> {
  return true === connection.simulate
    ? logoutAll.simulate(connection)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...logoutAll.METADATA,
          path: logoutAll.path(),
          status: null,
        },
      );
}
export namespace logoutAll {
  export const METADATA = {
    method: "POST",
    path: "/auth/siteAdmin/logoutAll",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/siteAdmin/logoutAll";
  export const random = (): void => typia.random<void>();
  export const simulate = (_connection: IConnection): void => {
    return random();
  };
}
