import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformGuestVisitor } from "../../../structures/ICommunityPlatformGuestVisitor";

/**
 * Register guestVisitor in community_platform_users and create session in
 * community_platform_sessions.
 *
 * Purpose and scope: This endpoint registers a temporary guest identity and
 * issues a session for smooth resume-after-login experiences without full
 * member credentials. A new account is created in the Prisma model
 * Actors.community_platform_users using required columns email,
 * email_normalized, username, username_normalized, and password_hash, with
 * optional display_name and last_login_at set on successful issuance. The
 * account timestamps created_at and updated_at are recorded for audit and
 * ordering. No membership privilege rows are created; specifically,
 * Actors.community_platform_registeredmembers and
 * Actors.community_platform_siteadmins remain absent for this account.
 *
 * Implementation details: After creating the user row, the service persists a
 * session in Sessions.community_platform_sessions with a securely generated
 * hashed_token (plaintext never stored), an absolute expires_at to satisfy
 * long-lived session targets, and optional
 * user_agent/ip/client_platform/client_device metadata. Timestamps
 * created_at/updated_at are set, and last_seen_at is recorded or initialized.
 * The session is returned to the client through the authorized response payload
 * so the UI can proceed with guarded actions that require being signed in as a
 * guest identity (e.g., preparing to upgrade flow, resuming blocked actions
 * after prompt).
 *
 * Role-specific integration: The guestVisitor role indicates an unauthenticated
 * browsing state prior to registration. Upon guest join, the user is
 * represented by the newly created community_platform_users row but remains a
 * guest (not a registered member). No entries are inserted into
 * Actors.community_platform_registeredmembers or
 * Actors.community_platform_siteadmins. Content write permissions remain
 * restricted per product rules; however, the session enables long-lived
 * identity for resume-after-login behavior and state continuity.
 *
 * Security considerations: Credentials are not reused from other roles. The
 * system must honor uniqueness via email_normalized and username_normalized,
 * and store only password_hash. Session tokens are represented only by
 * community_platform_sessions.hashed_token, never plaintext. Session expiry is
 * controlled by community_platform_sessions.expires_at, with renewal performed
 * via the companion refresh endpoint for this role. Optionally, last_login_at
 * in community_platform_users can be set to the current timestamp on successful
 * issuance.
 *
 * Validation and business logic: Minimal validation should respect the database
 * constraints and uniqueness enforced by email_normalized and
 * username_normalized. The application may auto-generate ephemeral values to
 * satisfy required columns in Actors.community_platform_users when the client
 * does not provide them. On uniqueness conflicts, return a suitable error
 * according to service conventions. No soft deletion semantics are applied
 * during creation; deleted_at columns remain null.
 *
 * Related operations and workflow: This join operation is typically followed by
 * the refresh endpoint for token renewal (Sessions.community_platform_sessions
 * rotation/extension). There is no login endpoint for the guestVisitor role by
 * design. Upgrading to member-level capabilities would be handled by separate
 * role-specific flows unrelated to this operation.
 *
 * @param props.connection
 * @param props.body Guest join payload (ephemeral identity inputs or empty;
 *   server may auto-generate required fields).
 * @setHeader token.access Authorization
 *
 * @path /auth/guestVisitor/join
 * @accessor api.functional.auth.guestVisitor.join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /**
     * Guest join payload (ephemeral identity inputs or empty; server may
     * auto-generate required fields).
     */
    body: ICommunityPlatformGuestVisitor.IJoin;
  };
  export type Body = ICommunityPlatformGuestVisitor.IJoin;
  export type Response = ICommunityPlatformGuestVisitor.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/guestVisitor/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/guestVisitor/join";
  export const random = (): ICommunityPlatformGuestVisitor.IAuthorized =>
    typia.random<ICommunityPlatformGuestVisitor.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Refresh guestVisitor session by rotating/updating
 * community_platform_sessions.
 *
 * Purpose and scope: This endpoint renews guestVisitor authentication by
 * refreshing a session represented in Prisma by
 * Sessions.community_platform_sessions. It validates the presented token (e.g.,
 * via a provided refresh token or secure cookie mapped to
 * community_platform_sessions.hashed_token), ensures the session is not revoked
 * (revoked_at is null) and not expired beyond renewal policy, and then rotates
 * or extends the session by updating expires_at and last_seen_at. The
 * corresponding user record in Actors.community_platform_users remains
 * unchanged beyond an optional update to last_login_at.
 *
 * Implementation details: A valid session row is required in
 * community_platform_sessions. On success, the endpoint may create a new
 * session record with a new hashed_token or update the existing one depending
 * on the rotation policy, always avoiding plaintext token storage. The response
 * returns an authorized structure that clients can use to continue guarded
 * flows after renewal. The actorâ€™s role remains guest; no rows are created in
 * Actors.community_platform_registeredmembers or
 * Actors.community_platform_siteadmins.
 *
 * Role-specific integration: This operation is specific to the guestVisitor
 * role and exists because kind is "guest". It complements the guest join flow
 * by extending long-lived sessions without requiring a member login. It must
 * enforce the association to Actors.community_platform_users via
 * community_platform_user_id, ensuring the user has not been deactivated (e.g.,
 * users.deleted_at is null) prior to renewal.
 *
 * Security considerations: Validate that community_platform_sessions.revoked_at
 * is null and community_platform_sessions.expires_at permits renewal. Always
 * store only the hashed token (community_platform_sessions.hashed_token).
 * Update last_seen_at to reflect the renewal activity, and set a new expires_at
 * within platform-defined bounds. Any invalid or expired token should result in
 * an appropriate unauthorized response per service conventions.
 *
 * Validation and business logic: The refresh request must supply sufficient
 * token context to locate the session (header/cookie or request body field).
 * The system must handle race conditions idempotently so the final state
 * contains exactly one active, non-revoked session for the guest account. No
 * soft deletion is performed by this operation; deleted_at columns remain
 * null.
 *
 * Related operations and workflow: Paired with the guestVisitor join endpoint.
 * There is no login for this role. Member/admin authentication flows are
 * separate and out of scope here.
 *
 * @param props.connection
 * @param props.body Refresh payload carrying token context to renew the guest
 *   session.
 * @setHeader token.access Authorization
 *
 * @path /auth/guestVisitor/refresh
 * @accessor api.functional.auth.guestVisitor.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /** Refresh payload carrying token context to renew the guest session. */
    body: ICommunityPlatformGuestVisitor.IRefresh;
  };
  export type Body = ICommunityPlatformGuestVisitor.IRefresh;
  export type Response = ICommunityPlatformGuestVisitor.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/guestVisitor/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/guestVisitor/refresh";
  export const random = (): ICommunityPlatformGuestVisitor.IAuthorized =>
    typia.random<ICommunityPlatformGuestVisitor.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
