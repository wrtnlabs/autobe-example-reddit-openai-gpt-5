import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformGuestVisitorJoin } from "../../../structures/ICommunityPlatformGuestVisitorJoin";
import { ICommunityPlatformGuestVisitor } from "../../../structures/ICommunityPlatformGuestVisitor";
import { ICommunityPlatformGuestVisitorRefresh } from "../../../structures/ICommunityPlatformGuestVisitorRefresh";

/**
 * Register or correlate an anonymous visitor and issue initial guest JWT using
 * community_platform_guestvisitors.
 *
 * Purpose and functionality: This endpoint creates or reuses an anonymous
 * visitor identity based on client hints and issues initial JWT tokens for the
 * guest role. It is backed by the Prisma model community_platform_guestvisitors
 * which captures device_fingerprint, user_agent, ip, and tracks first_seen_at
 * and last_seen_at timestamps for the same visitor. Unlike member or admin
 * flows, there is no lookup in community_platform_user_credentials and no
 * community_platform_sessions row, because the visitor is not an authenticated
 * user account.
 *
 * Implementation details: On request, the provider will either create a new row
 * in community_platform_guestvisitors (initializing first_seen_at and
 * last_seen_at) or update last_seen_at when correlating by device_fingerprint
 * and/or other hints. The endpoint returns access/refresh tokens encapsulated
 * in the ICommunityPlatformGuestVisitor.IAuthorized DTO with expiry metadata.
 * The returned tokens enable guarded actions to trigger the “Please sign in to
 * continue.” prompt logic and smooth resume as specified in business
 * requirements.
 *
 * Role-specific integration and business context: The role is a guest
 * (non-authenticated), mapped to the guestVisitor capability in the PRD. Guests
 * can browse public content and search but cannot create posts, comments, vote,
 * or join/leave. This endpoint exists to start a resumable session context for
 * guarded flows without elevating to a member account.
 *
 * Security considerations: Since no password or email exists for guests,
 * identity correlation uses
 * community_platform_guestvisitors.device_fingerprint, user_agent, and ip where
 * available. Tokens should be short-lived and scoped for read-only operations
 * plus guarded-flow resumption, and the service should update
 * community_platform_guestvisitors.last_seen_at each use to support abuse
 * detection and analytics via community_platform_audit_logs.guestvisitor_id.
 *
 * Related operations and workflow: Use this join endpoint first for brand-new
 * visitors. Later, call /auth/guestVisitor/refresh to rotate tokens using a
 * valid refresh token. Member/admin authentication flows are intentionally not
 * exposed here because those map to community_platform_users plus
 * community_platform_user_credentials and community_platform_sessions, which do
 * not apply to guests.
 *
 * Error handling: Return standard authentication errors for malformed payloads
 * or server-side failures. If client hints are missing, still create a minimal
 * community_platform_guestvisitors row and proceed. Do not reference soft
 * deletion semantics in this operation; the guest record lifecycle is
 * independent of token lifetime.
 *
 * @param props.connection
 * @param props.body Client-provided hints for correlating/creating an anonymous
 *   visitor (e.g., device fingerprint) and optional context.
 * @setHeader token.access Authorization
 *
 * @path /auth/guestVisitor/join
 * @accessor api.functional.auth.guestVisitor.join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /**
     * Client-provided hints for correlating/creating an anonymous visitor
     * (e.g., device fingerprint) and optional context.
     */
    body: ICommunityPlatformGuestVisitorJoin.ICreate;
  };
  export type Body = ICommunityPlatformGuestVisitorJoin.ICreate;
  export type Response = ICommunityPlatformGuestVisitor.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/guestVisitor/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/guestVisitor/join";
  export const random = (): ICommunityPlatformGuestVisitor.IAuthorized =>
    typia.random<ICommunityPlatformGuestVisitor.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Refresh guest JWT tokens linked to community_platform_guestvisitors without
 * using user sessions.
 *
 * Purpose and functionality: This endpoint renews guest access by accepting a
 * valid refresh token and returning a fresh
 * ICommunityPlatformGuestVisitor.IAuthorized payload. The underlying visitor
 * identity is represented by community_platform_guestvisitors with fields such
 * as device_fingerprint, user_agent, ip, first_seen_at, and last_seen_at.
 *
 * Implementation details: On successful refresh, the provider should validate
 * the presented guest refresh token, rotate tokens, and update
 * community_platform_guestvisitors.last_seen_at to the current time. Because
 * guests are not real accounts in community_platform_users and do not have
 * community_platform_user_credentials, no password checks or email verification
 * occurs here, and community_platform_sessions is not used for guest flows.
 *
 * Role-specific integration and business context: Guests can continue browsing
 * and be seamlessly prompted to sign in when attempting guarded actions. The
 * refresh process aligns with generous session expectations and smooth re-login
 * behavior outlined in the PRD while remaining distinct from member/admin
 * session renewal.
 *
 * Security considerations: Enforce refresh token validation and expiry, and
 * scope issued access tokens appropriately for guest capabilities. Track ip and
 * user_agent where available to support anomaly detection and correlate with
 * the community_platform_guestvisitors record for analytics, and optionally
 * emit community_platform_audit_logs entries linked via guestvisitor_id for
 * observability.
 *
 * Related operations and workflow: Initial token issuance occurs at
 * /auth/guestVisitor/join. If the refresh token is invalid, expired, or
 * revoked, the client should call /auth/guestVisitor/join to obtain a new token
 * set. This endpoint is intentionally separate from member/admin
 * /auth/{role}/refresh flows that rely on community_platform_sessions.
 *
 * Error handling: Return appropriate authentication errors for invalid/expired
 * refresh tokens. Do not mention or rely on soft-deletion behavior; token
 * rotation is independent from any archival settings on guest data.
 *
 * @param props.connection
 * @param props.body Refresh request containing the current guest refresh token
 *   and optional client context.
 * @setHeader token.access Authorization
 *
 * @path /auth/guestVisitor/refresh
 * @accessor api.functional.auth.guestVisitor.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /**
     * Refresh request containing the current guest refresh token and
     * optional client context.
     */
    body: ICommunityPlatformGuestVisitorRefresh.IRequest;
  };
  export type Body = ICommunityPlatformGuestVisitorRefresh.IRequest;
  export type Response = ICommunityPlatformGuestVisitor.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/guestVisitor/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/guestVisitor/refresh";
  export const random = (): ICommunityPlatformGuestVisitor.IAuthorized =>
    typia.random<ICommunityPlatformGuestVisitor.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
