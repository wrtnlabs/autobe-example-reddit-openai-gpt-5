import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformRegisteredMember } from "../../../structures/ICommunityPlatformRegisteredMember";
export * as sessions from "./sessions/index";
export * as password from "./password/index";

/**
 * Register a new account in community_platform_users and grant member role via
 * community_platform_registeredmembers.
 *
 * This operation registers a new member account and issues initial
 * authorization tokens. It creates a row in community_platform_users,
 * populating email, email_normalized, username, username_normalized,
 * password_hash, and optionally display_name. The schema enforces
 * case-insensitive uniqueness through email_normalized and username_normalized
 * unique indexes, which the application must populate from the provided
 * human-readable values. The last_login_at timestamp may be set at successful
 * issuance time to support security analytics.
 *
 * Upon successful user creation, the operation assigns the member capability by
 * inserting into community_platform_registeredmembers using
 * community_platform_user_id, with registered_at set to the current timestamp.
 * The role assignment table serves as the canonical indicator that the user is
 * an active registered member and includes created_at and updated_at for
 * auditability.
 *
 * For session management aligned with long-lived sessions and
 * resume-after-login, the endpoint creates a record in
 * community_platform_sessions linked by community_platform_user_id. The session
 * record stores hashed_token (never plaintext), expires_at within the absolute
 * lifetime window, and can capture user_agent, ip, client_platform, and
 * client_device when provided. The record also maintains last_seen_at for
 * session renewal behavior and updated_at for audit.
 *
 * Security considerations follow the schemaâ€™s guidance that password_hash is
 * the only stored credential derivative and that normalized uniqueness must be
 * used for conflicts. The operation should return an authorization payload
 * enabling immediate authenticated actions consistent with member permissions.
 *
 * Related operations include login for returning users and refresh for renewing
 * tokens. Clients typically call refresh in background to preserve long
 * sessions. Name and email normalization must be handled consistently so that
 * subsequent login comparisons can rely on email_normalized and
 * username_normalized.
 *
 * @param props.connection
 * @param props.body Registration payload for creating a member account.
 * @setHeader token.access Authorization
 *
 * @path /auth/registeredMember/join
 * @accessor api.functional.auth.registeredMember.join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /** Registration payload for creating a member account. */
    body: ICommunityPlatformRegisteredMember.IJoin;
  };
  export type Body = ICommunityPlatformRegisteredMember.IJoin;
  export type Response = ICommunityPlatformRegisteredMember.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/registeredMember/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/registeredMember/join";
  export const random = (): ICommunityPlatformRegisteredMember.IAuthorized =>
    typia.random<ICommunityPlatformRegisteredMember.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Sign in a registered member and create a session in
 * community_platform_sessions.
 *
 * This operation signs in an existing registered member using an identifier
 * (email or username) and password. The system locates the account via the
 * normalized columns email_normalized or username_normalized as defined in
 * community_platform_users, then validates the supplied password against
 * password_hash. When credentials are valid and the account is a registered
 * member (row exists in community_platform_registeredmembers), a fresh session
 * is established.
 *
 * A new record in community_platform_sessions is created using
 * community_platform_user_id with a securely generated token hash in
 * hashed_token and an expires_at timestamp that respects the absolute lifetime
 * requirement. The session may also store user_agent and ip strings, as well as
 * client_platform or client_device when available. The last_seen_at field can
 * be initialized or updated to the current time to facilitate idle-timeout
 * renewal policies.
 *
 * The operation updates users.last_login_at upon successful authentication to
 * support security and analytics. Audit timestamps such as created_at and
 * updated_at are maintained by the application layer consistent with the Prisma
 * model definitions.
 *
 * From a security perspective, the endpoint never returns or stores plaintext
 * credentials or tokens; only token material suitable for client storage is
 * returned and only hashed_token is persisted server-side. The response
 * includes authorization details enabling posting, commenting, voting,
 * joining/leaving communities, and editing/deleting authored content,
 * consistent with the registered member role.
 *
 * Clients should use the refresh endpoint to renew sessions and maintain
 * long-lived access without user friction. If the user does not have a
 * corresponding row in community_platform_registeredmembers, the application
 * should deny sign-in for member scope or prompt the registration flow.
 *
 * @param props.connection
 * @param props.body Login credentials for member authentication.
 * @setHeader token.access Authorization
 *
 * @path /auth/registeredMember/login
 * @accessor api.functional.auth.registeredMember.login
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function login(
  connection: IConnection,
  props: login.Props,
): Promise<login.Response> {
  const output: login.Response =
    true === connection.simulate
      ? login.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...login.METADATA,
            path: login.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace login {
  export type Props = {
    /** Login credentials for member authentication. */
    body: ICommunityPlatformRegisteredMember.ILogin;
  };
  export type Body = ICommunityPlatformRegisteredMember.ILogin;
  export type Response = ICommunityPlatformRegisteredMember.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/registeredMember/login",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/registeredMember/login";
  export const random = (): ICommunityPlatformRegisteredMember.IAuthorized =>
    typia.random<ICommunityPlatformRegisteredMember.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: login.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: login.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Refresh a member session using community_platform_sessions as source of
 * truth.
 *
 * This operation renews a member session to support long-lived authentication
 * with resume-after-login behavior. The server validates the presented token
 * context against community_platform_sessions by comparing a hash with
 * hashed_token, verifying that expires_at has not passed and revoked_at is
 * null. When valid, the operation may rotate the client-facing token and
 * updates last_seen_at to reflect recent activity per long-session policy.
 *
 * The session remains linked to the account via community_platform_user_id,
 * enabling downstream permission checks consistent with the registered memberâ€™s
 * capabilities across posting, commenting, voting, community creation, and
 * join/leave actions. No credential re-entry is required when a valid refresh
 * token is provided.
 *
 * Security considerations include ensuring that only hashed_token is stored,
 * observing absolute lifetime constraints (expires_at), and recording
 * updated_at to reflect the modification. The endpointâ€™s response returns a
 * fresh authorization payload consistent with the member role.
 *
 * Related operations include login for initial credential authentication and
 * logout endpoints for revocation. If validation fails because the session is
 * expired or revoked, the application should require a full login.
 *
 * @param props.connection
 * @param props.body Refresh token or session renewal payload.
 * @setHeader token.access Authorization
 *
 * @path /auth/registeredMember/refresh
 * @accessor api.functional.auth.registeredMember.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /** Refresh token or session renewal payload. */
    body: ICommunityPlatformRegisteredMember.IRefresh;
  };
  export type Body = ICommunityPlatformRegisteredMember.IRefresh;
  export type Response = ICommunityPlatformRegisteredMember.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/registeredMember/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/registeredMember/refresh";
  export const random = (): ICommunityPlatformRegisteredMember.IAuthorized =>
    typia.random<ICommunityPlatformRegisteredMember.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Log out from the current session by revoking community_platform_sessions
 * record.
 *
 * This operation logs the member out from the current device by revoking the
 * active session. It targets the corresponding row in
 * community_platform_sessions associated with the authenticated
 * community_platform_user_id and marks it as revoked by setting revoked_at. The
 * record may also update updated_at and last_seen_at to reflect the action.
 *
 * The users table community_platform_users is not modified for credential data
 * during logout; password_hash and identity fields remain unchanged. This
 * endpoint complements login and refresh by allowing users to explicitly end a
 * session while keeping reading access to public content.
 *
 * If the session is already revoked or expired (based on expires_at), the
 * system should treat the operation as idempotent and return success without
 * error to simplify client logic. Related operations include logoutAll to end
 * all sessions and revokeSession for targeted session management.
 *
 * @param props.connection
 * @param props.body Optional metadata for logout (e.g., client hints).
 * @path /auth/registeredMember/logout
 * @accessor api.functional.auth.registeredMember.logout
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function logout(
  connection: IConnection,
  props: logout.Props,
): Promise<logout.Response> {
  return true === connection.simulate
    ? logout.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...logout.METADATA,
          path: logout.path(),
          status: null,
        },
        props.body,
      );
}
export namespace logout {
  export type Props = {
    /** Optional metadata for logout (e.g., client hints). */
    body: ICommunityPlatformRegisteredMember.ILogoutRequest;
  };
  export type Body = ICommunityPlatformRegisteredMember.ILogoutRequest;
  export type Response = ICommunityPlatformRegisteredMember.ILogoutResult;

  export const METADATA = {
    method: "POST",
    path: "/auth/registeredMember/logout",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/registeredMember/logout";
  export const random = (): ICommunityPlatformRegisteredMember.ILogoutResult =>
    typia.random<ICommunityPlatformRegisteredMember.ILogoutResult>();
  export const simulate = (
    connection: IConnection,
    props: logout.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: logout.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Revoke all active sessions for the member in community_platform_sessions.
 *
 * This operation signs the member out of all devices by revoking every active
 * session linked to the account. It identifies sessions via
 * community_platform_user_id in community_platform_sessions and sets revoked_at
 * on each currently valid session. The action is idempotent; repeating it after
 * all sessions are already revoked produces no side effects.
 *
 * No changes are made to credentials in community_platform_users such as
 * password_hash, and the role assignment in
 * community_platform_registeredmembers remains intact. This complements the
 * single-session logout and can be offered as a security control in profile
 * settings.
 *
 * If some sessions are already expired based on expires_at, they can be
 * included in the revocation sweep without error. Clients typically return to
 * read-only state after completion.
 *
 * @param props.connection
 * @path /auth/registeredMember/logoutAll
 * @accessor api.functional.auth.registeredMember.logoutAll
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function logoutAll(
  connection: IConnection,
): Promise<logoutAll.Response> {
  return true === connection.simulate
    ? logoutAll.simulate(connection)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...logoutAll.METADATA,
          path: logoutAll.path(),
          status: null,
        },
      );
}
export namespace logoutAll {
  export type Response = ICommunityPlatformRegisteredMember.ILogoutAllResult;

  export const METADATA = {
    method: "POST",
    path: "/auth/registeredMember/logoutAll",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/registeredMember/logoutAll";
  export const random =
    (): ICommunityPlatformRegisteredMember.ILogoutAllResult =>
      typia.random<ICommunityPlatformRegisteredMember.ILogoutAllResult>();
  export const simulate = (_connection: IConnection): Response => {
    return random();
  };
}
