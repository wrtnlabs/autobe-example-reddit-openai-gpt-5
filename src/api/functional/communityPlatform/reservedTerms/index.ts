import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformReservedTerm } from "../../../structures/ICommunityPlatformReservedTerm";
import { IPageICommunityPlatformReservedTerm } from "../../../structures/IPageICommunityPlatformReservedTerm";

/**
 * Search and paginate reserved terms (community_platform_reserved_terms).
 *
 * This operation lists records from community_platform_reserved_terms, which
 * the schema defines as an administrative list of reserved terms used to
 * validate and block specific names or identifiers (e.g., community names,
 * system-reserved words). Each record contains the original term, a normalized
 * variant for case-insensitive matching (term_normalized), the applies_to
 * context (such as 'community_name' or 'global'), an optional reason, an active
 * flag, and standard timestamps.
 *
 * Security posture: read-only and primarily administrative/reference in nature,
 * yet it may be publicly consumable depending on product policy. For broad
 * validation transparency, this document sets the endpoint as public read.
 * Implementations should filter out records where deleted_at is not null.
 * Additional filtering by active allows clients to see only enforced terms when
 * needed.
 *
 * Data and validation rules: the listing supports free-text search against term
 * (and optionally term_normalized), filtering by applies_to and active, and
 * sorting by created_at (default), term, or applies_to. Clients should paginate
 * results (page/limit or cursor approach) to keep responses performant. Indices
 * on term and term_normalized (trigram) support efficient search behavior for
 * partial matches.
 *
 * Related operations include GET /reservedTerms/{reservedTermId} for detail
 * retrieval. Expected behavior includes stable ordering within a page, clear
 * differentiation between empty results and invalid filters, and consistent
 * exclusion of records that have a non-null deleted_at value.
 *
 * @param props.connection
 * @param props.body Search, filter, sort, and pagination parameters for
 *   reserved terms
 * @path /communityPlatform/reservedTerms
 * @accessor api.functional.communityPlatform.reservedTerms.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Search, filter, sort, and pagination parameters for reserved terms */
    body: ICommunityPlatformReservedTerm.IRequest;
  };
  export type Body = ICommunityPlatformReservedTerm.IRequest;
  export type Response = IPageICommunityPlatformReservedTerm.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/communityPlatform/reservedTerms",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/communityPlatform/reservedTerms";
  export const random = (): IPageICommunityPlatformReservedTerm.ISummary =>
    typia.random<IPageICommunityPlatformReservedTerm.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get a single reserved term (community_platform_reserved_terms) by ID.
 *
 * This operation loads one record from community_platform_reserved_terms using
 * the reservedTermId path parameter (UUID). Per the schema comments, each
 * reserved term captures the original term, a normalized version for
 * case-insensitive uniqueness, the target context via applies_to, an optional
 * reason explaining the reservation, an active flag, and lifecycle timestamps.
 * The uniqueness constraint on (applies_to, term_normalized) guarantees
 * consistent enforcement across contexts.
 *
 * Security considerations: this is a read-only endpoint and is configured as
 * public for transparency. Implementations should not return records with
 * deleted_at populated. If the identifier does not resolve to an existing
 * eligible record, return a not-found response.
 *
 * Validation and behavior: ensure the parameter is a valid UUID and that the
 * record exists. The response returns the reserved term entity only; related
 * validation logic that consumes these terms occurs elsewhere. Consistent error
 * handling and absence of internal details ensure stable client integrations.
 *
 * @param props.connection
 * @param props.reservedTermId Unique identifier of the reserved term (UUID)
 * @path /communityPlatform/reservedTerms/:reservedTermId
 * @accessor api.functional.communityPlatform.reservedTerms.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the reserved term (UUID) */
    reservedTermId: string & tags.Format<"uuid">;
  };
  export type Response = ICommunityPlatformReservedTerm;

  export const METADATA = {
    method: "GET",
    path: "/communityPlatform/reservedTerms/:reservedTermId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/reservedTerms/${encodeURIComponent(props.reservedTermId ?? "null")}`;
  export const random = (): ICommunityPlatformReservedTerm =>
    typia.random<ICommunityPlatformReservedTerm>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("reservedTermId")(() => typia.assert(props.reservedTermId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
