import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformRegisteredMember } from "../../../../structures/ICommunityPlatformRegisteredMember";
import { IPageICommunityPlatformRegisteredMember } from "../../../../structures/IPageICommunityPlatformRegisteredMember";

/**
 * List/search registered member assignments (table:
 * community_platform_registeredmembers).
 *
 * Retrieve a paginated, filterable list of registered member assignments from
 * the community_platform_registeredmembers table. Per the Prisma schema
 * comments, each row marks a community_platform_users account as an active
 * registered member with write capabilities. The model defines: id (UUID
 * primary key), community_platform_user_id (FK), registered_at (assignment
 * time), created_at/updated_at for audit and ordering, and a nullable
 * deleted_at used to hide deactivated records. A unique constraint on
 * (community_platform_user_id) ensures a single assignment per user.
 *
 * Security and authorization: This is an administrative read operation intended
 * for privileged operators. Access is restricted to users with the platform’s
 * administrative privileges (siteAdmin). Read access should exclude deactivated
 * rows by default by checking deleted_at is null, unless an explicit
 * administrative filter is provided by business logic. No personal credentials
 * are exposed; only assignment metadata is returned in summary form.
 *
 * Relationship to underlying entities:
 * community_platform_registeredmembers.user references community_platform_users
 * via community_platform_user_id with onDelete: Cascade, reflecting that
 * removing a user account will also remove the member assignment. This endpoint
 * is read-only; it does not modify user role state.
 *
 * Validation, sorting, and pagination: The request supports optional filters
 * including community_platform_user_id and time windows (e.g., registered_at,
 * created_at). Deterministic ordering follows platform rules: default sort by
 * created_at descending, breaking ties with id descending. Cursor-based
 * pagination uses the last item’s ordering tuple to continue without duplicates
 * or gaps.
 *
 * Related operations: Use GET
 * /communityPlatform/siteAdmin/registeredMembers/{registeredMemberId} to
 * retrieve a single assignment’s full detail. Administrative workflows that
 * grant or revoke member capability are handled elsewhere and are not part of
 * this read API.
 *
 * Error handling: Invalid filters yield 400 responses. If the caller lacks
 * permission, respond with 401/403 according to authentication/authorization
 * checks. Temporary backend issues return a generic recoverable error message.
 *
 * @param props.connection
 * @param props.body Search, filter, sort, and paginate registered members list.
 * @path /communityPlatform/siteAdmin/registeredMembers
 * @accessor api.functional.communityPlatform.siteAdmin.registeredMembers.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Search, filter, sort, and paginate registered members list. */
    body: ICommunityPlatformRegisteredMember.IRequest;
  };
  export type Body = ICommunityPlatformRegisteredMember.IRequest;
  export type Response = IPageICommunityPlatformRegisteredMember.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/communityPlatform/siteAdmin/registeredMembers",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/communityPlatform/siteAdmin/registeredMembers";
  export const random = (): IPageICommunityPlatformRegisteredMember.ISummary =>
    typia.random<IPageICommunityPlatformRegisteredMember.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get details of a registered member assignment by id (table:
 * community_platform_registeredmembers).
 *
 * This operation fetches one record from community_platform_registeredmembers
 * using its UUID id. The Prisma model marks a user as a registered member with
 * fields: id (PK), community_platform_user_id (FK to community_platform_users),
 * registered_at (when the capability was granted), created_at/updated_at, and
 * deleted_at (nullable). The referenced user is linked with onDelete: Cascade.
 *
 * Security and permissions: Access is limited to administrators with siteAdmin
 * privileges. Applications commonly hide records where deleted_at is not null;
 * provider logic may treat such rows as inactive. This endpoint is strictly
 * read-only and does not alter membership state.
 *
 * Behavior and errors: If the id does not correspond to an existing row or the
 * row is hidden by policy, respond with 404. Invalid UUID formats result in
 * 400. Authentication failures return 401, and authorization failures return
 * 403. Transient errors should return a recoverable error response.
 *
 * @param props.connection
 * @param props.registeredMemberId Target registered member assignment’s UUID.
 * @path /communityPlatform/siteAdmin/registeredMembers/:registeredMemberId
 * @accessor api.functional.communityPlatform.siteAdmin.registeredMembers.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Target registered member assignment’s UUID. */
    registeredMemberId: string & tags.Format<"uuid">;
  };
  export type Response = ICommunityPlatformRegisteredMember;

  export const METADATA = {
    method: "GET",
    path: "/communityPlatform/siteAdmin/registeredMembers/:registeredMemberId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/siteAdmin/registeredMembers/${encodeURIComponent(props.registeredMemberId ?? "null")}`;
  export const random = (): ICommunityPlatformRegisteredMember =>
    typia.random<ICommunityPlatformRegisteredMember>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("registeredMemberId")(() =>
        typia.assert(props.registeredMemberId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
