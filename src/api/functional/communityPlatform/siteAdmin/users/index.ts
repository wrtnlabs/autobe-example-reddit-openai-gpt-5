import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformUser } from "../../../../structures/ICommunityPlatformUser";
import { IPageICommunityPlatformUser } from "../../../../structures/IPageICommunityPlatformUser";

/**
 * Search and list accounts from community_platform_users with pagination and
 * sorting.
 *
 * Retrieve a filtered, sorted, and paginated list of user accounts stored in
 * the Prisma model community_platform_users. The underlying table includes id
 * (UUID), email, email_normalized, username, username_normalized,
 * password_hash, optional display_name, last_login_at, created_at, updated_at,
 * and optional deleted_at. Per the schema comments, email_normalized and
 * username_normalized enforce case-insensitive uniqueness at the database
 * layer; these are not user-facing fields but can be used for exact/CI matches
 * in search logic.
 *
 * Security and permissions: This operation is intended for administrative
 * back-office usage. Only authorized operators should be able to list arbitrary
 * accounts. The operation must never include password_hash or other sensitive
 * columns in the payload. Business logic may also mask portions of email for
 * privacy. Deleted accounts (deleted_at set) should be excluded by default
 * unless an explicit filter is provided for compliance views.
 *
 * Entity relationships: Users relate to role assignment tables
 * community_platform_registeredmembers (member state) and
 * community_platform_siteadmins (administrative state), to session records in
 * community_platform_sessions (long-lived sessions), and to content tables
 * (communities they created, posts, comments, votes). When producing summaries,
 * you can derive boolean flags like isMember or isSiteAdmin by probing the
 * existence of related role rows.
 *
 * Validation and business logic: Support free-text search over
 * username/display_name using trigram indices (as declared in Prisma indexes)
 * and optional exact/CI match on email/username via normalized columns. Sorting
 * typically includes created_at (Newest), last_login_at (recent activity), or
 * username ascending. Pagination follows cursor-based continuation using the
 * active sortâ€™s tiebreakers (e.g., created_at + id for Newest). Respect minimal
 * validation to keep flows smooth.
 *
 * Related operations: Use GET /users/{userId} to fetch a single account detail.
 * Use PUT /users/{userId} to update allowed profile fields (e.g., display_name,
 * username/email with uniqueness checks). Use DELETE /users/{userId} to
 * deactivate an account (sets deleted_at) when policy requires.
 *
 * Expected behavior and error handling: Return a stable page of up to 20 items
 * by default with pageInfo.nextCursor when more data exists. Reject unsupported
 * sort values. Do not expose password_hash or normalized keys. If a temporary
 * error occurs, return a standardized transient error message. Ownership rules
 * do not apply to this admin-level index, so enforce authorization globally.
 *
 * @param props.connection
 * @param props.body Search, filter, sort, and pagination parameters for user
 *   listing
 * @path /communityPlatform/siteAdmin/users
 * @accessor api.functional.communityPlatform.siteAdmin.users.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Search, filter, sort, and pagination parameters for user listing */
    body: ICommunityPlatformUser.IRequest;
  };
  export type Body = ICommunityPlatformUser.IRequest;
  export type Response = IPageICommunityPlatformUser.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/communityPlatform/siteAdmin/users",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/communityPlatform/siteAdmin/users";
  export const random = (): IPageICommunityPlatformUser.ISummary =>
    typia.random<IPageICommunityPlatformUser.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
