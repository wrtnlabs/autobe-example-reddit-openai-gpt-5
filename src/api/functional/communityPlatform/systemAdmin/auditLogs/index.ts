import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformAuditLog } from "../../../../structures/ICommunityPlatformAuditLog";
import { IPageICommunityPlatformAuditLog } from "../../../../structures/IPageICommunityPlatformAuditLog";

/**
 * Search and paginate administrative audit logs
 * (community_platform_audit_logs).
 *
 * This operation lists audit entries stored in the
 * community_platform_audit_logs table, which captures general-purpose,
 * append-only records of significant events, such as joins/leaves, content
 * creation/deletion, voting, authentication, and administrative actions. The
 * schema fields include actor_user_id, session_id, guestvisitor_id,
 * community_id, post_id, comment_id, membership_id, event_type, success,
 * details, ip, user_agent, and created_at/updated_at timestamps. Records use
 * deleted_at as a logical removal timestamp; list responses should exclude
 * records where deleted_at is not null unless an explicit administrative
 * retrieval mode is required.
 *
 * Security and authorization: Only users holding the systemAdmin role are
 * allowed to access this listing. The endpoint is strictly read-only and
 * intended for audit/compliance workflows. Requests should be rate-limited and
 * observable. The provider must ensure no sensitive tokens are exposed (only
 * internal identifiers and metadata logged in the audit table).
 *
 * Relationship context: Although the list originates from
 * community_platform_audit_logs, it may filter or enrich results using
 * relations to community_platform_users (actor), community_platform_sessions
 * (session correlation), community_platform_guestvisitors (unauthenticated
 * actor), community_platform_communities, community_platform_posts,
 * community_platform_comments, and community_platform_community_memberships
 * when those foreign keys are present. These relations are optional and should
 * be joined only when needed by filters or projection.
 *
 * Validation and business logic: Support filters on event_type (exact or set),
 * success flag, time windows using created_at range, and resource scoping
 * (e.g., by community_id, post_id, comment_id, membership_id). Sorting defaults
 * to created_at desc with a deterministic tiebreaker by id when timestamps
 * match. Pagination should be implemented to return manageable pages for UI
 * list rendering.
 *
 * Related operations: Use GET /auditLogs/{auditLogId} to retrieve full details
 * of a single audit record when an entry from this list is selected. Errors
 * should follow standard patterns; attempts by non-admins must be denied with
 * appropriate authorization handling.
 *
 * @param props.connection
 * @param props.body Search criteria, time-range, sorting, and pagination for
 *   audit log retrieval.
 * @path /communityPlatform/systemAdmin/auditLogs
 * @accessor api.functional.communityPlatform.systemAdmin.auditLogs.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search criteria, time-range, sorting, and pagination for audit log
     * retrieval.
     */
    body: ICommunityPlatformAuditLog.IRequest;
  };
  export type Body = ICommunityPlatformAuditLog.IRequest;
  export type Response = IPageICommunityPlatformAuditLog.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/communityPlatform/systemAdmin/auditLogs",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/communityPlatform/systemAdmin/auditLogs";
  export const random = (): IPageICommunityPlatformAuditLog.ISummary =>
    typia.random<IPageICommunityPlatformAuditLog.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get details of a single audit log (community_platform_audit_logs).
 *
 * This operation returns one immutable audit record from
 * community_platform_audit_logs identified by its primary key. The table stores
 * append-only snapshots of significant events. Columns include actor_user_id,
 * session_id, guestvisitor_id, community_id, post_id, comment_id,
 * membership_id, event_type, success, optional details, ip, user_agent, and
 * created_at/updated_at timestamps. Records with a non-null deleted_at
 * represent logically removed entries and should normally be excluded unless an
 * explicit admin retrieval mode is required.
 *
 * Security and permissions: Access is limited to users holding the systemAdmin
 * role. The response is for read-only investigative purposes; no mutation is
 * supported. Providers should avoid exposing sensitive secrets while returning
 * the metadata stored in the audit table.
 *
 * Relationships and context: The response may be resolved with optional
 * associations (actor user, session, guest visitor, and resource targets) for
 * context in admin tooling, but the canonical source is the
 * community_platform_audit_logs row selected by id.
 *
 * Error handling: If the identifier does not exist or the record has been
 * logically removed from active views, return a not-found outcome. Unauthorized
 * access attempts must be denied according to platform policy.
 *
 * @param props.connection
 * @param props.auditLogId Unique identifier of the audit log record to
 *   retrieve.
 * @path /communityPlatform/systemAdmin/auditLogs/:auditLogId
 * @accessor api.functional.communityPlatform.systemAdmin.auditLogs.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the audit log record to retrieve. */
    auditLogId: string & tags.Format<"uuid">;
  };
  export type Response = ICommunityPlatformAuditLog;

  export const METADATA = {
    method: "GET",
    path: "/communityPlatform/systemAdmin/auditLogs/:auditLogId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/systemAdmin/auditLogs/${encodeURIComponent(props.auditLogId ?? "null")}`;
  export const random = (): ICommunityPlatformAuditLog =>
    typia.random<ICommunityPlatformAuditLog>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("auditLogId")(() => typia.assert(props.auditLogId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
