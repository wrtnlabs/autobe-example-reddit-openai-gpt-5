import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformAppSetting } from "../../../../structures/ICommunityPlatformAppSetting";
import { IPageICommunityPlatformAppSetting } from "../../../../structures/IPageICommunityPlatformAppSetting";

/**
 * List/search application settings from Prisma table
 * community_platform_app_settings with pagination for admins.
 *
 * This operation lists configuration settings from the
 * community_platform_app_settings table for administrative review and
 * management scenarios. Per the Prisma schema comments, this table holds
 * key-value configuration entries that control platform behavior, including
 * feature flags and policy values. Each entry includes a unique key, a string
 * value (parsed by application logic), a value_type semantic hint, an optional
 * description, an active boolean, and lifecycle timestamps (created_at,
 * updated_at). Records with a non-null deleted_at are considered removed from
 * active views and should be excluded from normal listings.
 *
 * Security-wise, configuration data is sensitive and intended for platform
 * administrators. Only users with elevated privileges should access this
 * endpoint. The endpoint designates authorizationRoles to "systemAdmin" based
 * on the role assignment model community_platform_systemadmins, which captures
 * platform administrators via a dedicated assignment table.
 *
 * The request body ICommunityPlatformAppSetting.IRequest supports pagination
 * (page, limit), free-text search over key/description, filtering by active and
 * value_type, and sorting by created_at, updated_at, key, or display-friendly
 * fields. Sorting should allow ascending/descending control and deterministic
 * tie-breaking when values are equal. The response
 * IPageICommunityPlatformAppSetting.ISummary provides a stable page container
 * including pagination metadata and an array of summary items containing
 * essential fields such as id, key, value_type, active, and updated_at suitable
 * for list renderings.
 *
 * Related operations include retrieving an individual setting by id via GET
 * /appSettings/{appSettingId}. Administrative write operations
 * (create/update/delete) are intentionally not exposed here, aligning with
 * selective API surface principles unless explicitly required elsewhere. Error
 * handling should return appropriate authorization errors for non-admin callers
 * and support validation messages for malformed search/sort parameters.
 *
 * @param props.connection
 * @param props.body Search criteria, sorting, and pagination parameters for
 *   application settings.
 * @path /communityPlatform/systemAdmin/appSettings
 * @accessor api.functional.communityPlatform.systemAdmin.appSettings.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search criteria, sorting, and pagination parameters for application
     * settings.
     */
    body: ICommunityPlatformAppSetting.IRequest;
  };
  export type Body = ICommunityPlatformAppSetting.IRequest;
  export type Response = IPageICommunityPlatformAppSetting.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/communityPlatform/systemAdmin/appSettings",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/communityPlatform/systemAdmin/appSettings";
  export const random = (): IPageICommunityPlatformAppSetting.ISummary =>
    typia.random<IPageICommunityPlatformAppSetting.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get a specific app setting (community_platform_app_settings) by ID for admin
 * inspection.
 *
 * This operation fetches one configuration record from
 * community_platform_app_settings using its primary key id (UUID). According to
 * the Prisma schema comments, the table stores platform-wide configuration
 * entries with a unique key, a string value, value_type (semantic hint),
 * optional description, an active flag, and created_at/updated_at timestamps.
 * Records where deleted_at is non-null are considered removed from active use;
 * typical implementations should not return such entries to standard callers
 * unless an audit context explicitly requires it.
 *
 * Access is restricted to platform administrators due to the sensitive nature
 * of configuration data. The authorization role aligns with the system
 * administrator assignment captured in community_platform_systemadmins. The
 * endpoint returns a detailed ICommunityPlatformAppSetting representation
 * suitable for admin detail views and subsequent decision-making.
 *
 * If the id does not correspond to an active configuration entry, the service
 * should respond with a not-found outcome. If the caller lacks sufficient
 * privileges, return an authorization error consistent with platform security
 * guidelines. This endpoint is typically used together with the list/search
 * endpoint PATCH /appSettings for navigation from a list to a detail view.
 *
 * @param props.connection
 * @param props.appSettingId Unique identifier of the target application setting
 *   (UUID).
 * @path /communityPlatform/systemAdmin/appSettings/:appSettingId
 * @accessor api.functional.communityPlatform.systemAdmin.appSettings.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the target application setting (UUID). */
    appSettingId: string & tags.Format<"uuid">;
  };
  export type Response = ICommunityPlatformAppSetting;

  export const METADATA = {
    method: "GET",
    path: "/communityPlatform/systemAdmin/appSettings/:appSettingId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/systemAdmin/appSettings/${encodeURIComponent(props.appSettingId ?? "null")}`;
  export const random = (): ICommunityPlatformAppSetting =>
    typia.random<ICommunityPlatformAppSetting>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("appSettingId")(() => typia.assert(props.appSettingId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
