import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformCommunityRule } from "../../../../structures/ICommunityPlatformCommunityRule";
import { IPageICommunityPlatformCommunityRule } from "../../../../structures/IPageICommunityPlatformCommunityRule";

/**
 * List community rules (community_platform_community_rules) for a community
 * with pagination and sorting.
 *
 * This operation lists rule rows stored in community_platform_community_rules
 * for a specific community (community_platform_community_id). The schema
 * defines fields including order_index (unique per community to preserve
 * deterministic order), text (1–200 chars), and lifecycle timestamps
 * (created_at, updated_at, deleted_at). Each rule belongs to a
 * community_platform_communities record. The default display order in product
 * requirements is the preserved owner-defined ordering, which this endpoint
 * reflects by sorting primarily by order_index and secondarily by created_at
 * for stability.
 *
 * Security and visibility: Rules are public presentation metadata of a
 * community and can be retrieved without authentication. The provider logic
 * should filter out records with non-null deleted_at so only active rules are
 * returned. Consumers typically display the first 5 items by default and allow
 * expansion to the full set as needed.
 *
 * Query capabilities: The request body accepts pagination (page/size or
 * cursor-based fields), optional free-text search against text, and sorting
 * options (e.g., order_index asc by default, with tie-breaker on created_at).
 * The response returns a paginated container including items and pagination
 * metadata useful for load-more interactions.
 *
 * Related operations: Use POST /communityPlatform/communityMember/communities
 * to create the community, PUT
 * /communityPlatform/communityMember/communities/{communityId} to edit its
 * metadata, and DELETE
 * /communityPlatform/communityMember/communities/{communityId} to remove it
 * from public surfaces. Errors include not found (invalid communityId) and
 * invalid pagination or sorting parameters.
 *
 * @param props.connection
 * @param props.communityId Identifier of the community whose rules are being
 *   listed.
 * @param props.body Search, filtering, and pagination parameters for retrieving
 *   community rules.
 * @path /communityPlatform/communities/:communityId/rules
 * @accessor api.functional.communityPlatform.communities.rules.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Identifier of the community whose rules are being listed. */
    communityId: string & tags.Format<"uuid">;

    /**
     * Search, filtering, and pagination parameters for retrieving community
     * rules.
     */
    body: ICommunityPlatformCommunityRule.IRequest;
  };
  export type Body = ICommunityPlatformCommunityRule.IRequest;
  export type Response = IPageICommunityPlatformCommunityRule;

  export const METADATA = {
    method: "PATCH",
    path: "/communityPlatform/communities/:communityId/rules",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPlatform/communities/${encodeURIComponent(props.communityId ?? "null")}/rules`;
  export const random = (): IPageICommunityPlatformCommunityRule =>
    typia.random<IPageICommunityPlatformCommunityRule>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get a single rule from community_platform_community_rules by community and
 * rule identifiers.
 *
 * This operation returns the details of a single rule record from the
 * community_platform_community_rules table. According to the schema comments,
 * each rule is an ordered item authored by the community owner to set
 * participation expectations, and includes a stable order_index per community
 * to preserve deterministic ordering. The returned fields include the rule
 * identifier, the parent community identifier, the display order, the rule text
 * (1–200 chars), and the standard timestamps.
 *
 * Security and permissions: Reading public communities, posts, comments, and
 * their metadata is open to everyone as per the product requirements. Therefore
 * this read endpoint is public. Even though the underlying table contains
 * ownership semantics (rules managed by the community owner), retrieval does
 * not require authentication.
 *
 * Database relationships: The rule references community_platform_communities
 * via community_platform_community_id (onDelete: Cascade). The client must
 * specify both the parent communityId and the ruleId to scope the request to
 * the correct parent entity. Providers should ensure that only active
 * (deleted_at IS NULL) rules are returned.
 *
 * Validation and behavior: The provider should validate that the specified rule
 * belongs to the specified community. If the record is missing or marked
 * deleted (deleted_at not null), respond with a not-found outcome at the
 * business layer. Related endpoints include POST
 * /communityPlatform/communityMember/communities/{communityId}/rules for
 * creation, PUT
 * /communityPlatform/communityMember/communities/{communityId}/rules/{ruleId}
 * for updates, and DELETE
 * /communityPlatform/communityMember/communities/{communityId}/rules/{ruleId}
 * for removal.
 *
 * @param props.connection
 * @param props.communityId Parent community’s ID (UUID) that owns the rule
 * @param props.ruleId Target rule’s ID (UUID) within the specified community
 * @path /communityPlatform/communities/:communityId/rules/:ruleId
 * @accessor api.functional.communityPlatform.communities.rules.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Parent community’s ID (UUID) that owns the rule */
    communityId: string & tags.Format<"uuid">;

    /** Target rule’s ID (UUID) within the specified community */
    ruleId: string & tags.Format<"uuid">;
  };
  export type Response = ICommunityPlatformCommunityRule;

  export const METADATA = {
    method: "GET",
    path: "/communityPlatform/communities/:communityId/rules/:ruleId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/communities/${encodeURIComponent(props.communityId ?? "null")}/rules/${encodeURIComponent(props.ruleId ?? "null")}`;
  export const random = (): ICommunityPlatformCommunityRule =>
    typia.random<ICommunityPlatformCommunityRule>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
      assert.param("ruleId")(() => typia.assert(props.ruleId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
