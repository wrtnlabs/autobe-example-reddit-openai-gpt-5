import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformPost } from "../../../../structures/ICommunityPlatformPost";
import { IPageICommunityPlatformPost } from "../../../../structures/IPageICommunityPlatformPost";

/**
 * Search and list posts for a community from community_platform_posts with
 * sorting and pagination.
 *
 * Retrieve a filtered, sorted, and paginated list of posts from the
 * community_platform_posts table for a given community. The Prisma schema
 * defines key columns: id, community_platform_community_id (parent community),
 * author_user_id (nullable to support account closure/anonymization), title
 * (5–120 chars business rule), body (10–10,000 chars business rule, plain
 * text), optional author_display_name (0–32 chars), created_at/updated_at, and
 * a deleted_at timestamp for logical removal from public view. Relationships
 * include references to community_platform_communities (container),
 * community_platform_users (author), community_platform_post_votes (for score),
 * and community_platform_comments (for comment counts).
 *
 * Sorting and search: Implement canonical sorts per requirements—Newest orders
 * by created_at descending with tie-breakers by larger identifier; Top orders
 * by higher score first (derived from community_platform_post_votes, where
 * state indicates up/down), then more recent created_at, then larger
 * identifier. Title/body matching leverages the schema’s trigram indexes on
 * title and body. Pagination returns 20 items per page by default, with
 * deterministic order and no duplicates across pages.
 *
 * Security and visibility: Reading posts is public per platform rules, but the
 * provider must exclude posts where deleted_at is set and should suppress
 * content from communities that are administratively disabled (disabled_at) on
 * promotion surfaces. The author_user_id being nullable requires display
 * fallbacks (e.g., anonymous attribution) based on business logic; this listing
 * returns summary fields suitable for feed cards.
 *
 * Validation and errors: Validate communityId as a UUID referencing an existing
 * community. Return 404 for non-existent communities and 400 for invalid
 * parameters. The request body controls filters, sort selection (Newest | Top),
 * and pagination cursors/limits.
 *
 * Related operations: Creation, update, and deletion of posts are separate
 * endpoints. This operation focuses solely on complex retrieval tailored to
 * community feeds, built on community_platform_posts and its related
 * vote/comment aggregates.
 *
 * @param props.connection
 * @param props.communityId Target community’s ID
 *   (community_platform_communities.id)
 * @param props.body Filter, search, sort (Newest | Top), and pagination
 *   parameters for community posts
 * @path /communityPlatform/communities/:communityId/posts
 * @accessor api.functional.communityPlatform.communities.posts.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Target community’s ID (community_platform_communities.id) */
    communityId: string & tags.Format<"uuid">;

    /**
     * Filter, search, sort (Newest | Top), and pagination parameters for
     * community posts
     */
    body: ICommunityPlatformPost.IRequest;
  };
  export type Body = ICommunityPlatformPost.IRequest;
  export type Response = IPageICommunityPlatformPost.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/communityPlatform/communities/:communityId/posts",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPlatform/communities/${encodeURIComponent(props.communityId ?? "null")}/posts`;
  export const random = (): IPageICommunityPlatformPost.ISummary =>
    typia.random<IPageICommunityPlatformPost.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
