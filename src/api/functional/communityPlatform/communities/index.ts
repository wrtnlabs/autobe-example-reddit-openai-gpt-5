import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformCommunity } from "../../../structures/ICommunityPlatformCommunity";
import { IPageICommunityPlatformCommunity } from "../../../structures/IPageICommunityPlatformCommunity";
export * as rules from "./rules/index";
export * as posts from "./posts/index";

/**
 * Search and list communities (community_platform_communities).
 *
 * This operation returns a paginated list of communities based on the
 * community_platform_communities table. Key columns include id,
 * community_platform_user_id (creator), name, name_key (normalized uniqueness),
 * category, description, logo_uri, banner_uri, last_active_at, created_at,
 * updated_at, and deleted_at. Client UIs commonly present name, short
 * description, logo/banner (when present), created timing, and membership count
 * (computed from community_platform_community_members) without exposing
 * underlying IDs.
 *
 * Security and visibility: the endpoint is public for reading. Normal responses
 * should exclude records where deleted_at is set, ensuring only active
 * communities are listed. Content is readable to all roles.
 *
 * Ordering and pagination: default ordering for Explore lists is by recently
 * created (created_at desc, then id desc for ties). Category filtering is
 * supported via the category column, and name-based matching may be applied at
 * the application layer using name/name_key and trigram indexes defined in the
 * schema. Use cursor-based pagination derived from the active sort’s key tuple
 * to return 20 items per page by default, with deterministic continuation.
 *
 * Related tables and counts: memberCount in cards can be derived from
 * community_platform_community_members per community, counting rows where
 * deleted_at is null. Rules shown in the right sidebar originate from
 * community_platform_community_rules; only the top 5 rules (by order_index) are
 * commonly displayed on detail pages and are not required in this listing
 * response.
 *
 * Error handling: transient failures return standard temporary error copy;
 * validation errors on filters return 400-series responses with clear messages.
 * Timestamps are ISO-8601 in UTC.
 *
 * @param props.connection
 * @param props.body Search, filter, sort, and pagination parameters for
 *   communities discovery.
 * @path /communityPlatform/communities
 * @accessor api.functional.communityPlatform.communities.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search, filter, sort, and pagination parameters for communities
     * discovery.
     */
    body: ICommunityPlatformCommunity.IRequest;
  };
  export type Body = ICommunityPlatformCommunity.IRequest;
  export type Response = IPageICommunityPlatformCommunity.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/communityPlatform/communities",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/communityPlatform/communities";
  export const random = (): IPageICommunityPlatformCommunity.ISummary =>
    typia.random<IPageICommunityPlatformCommunity.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get a community by name from community_platform_communities.
 *
 * Purpose and Overview: Fetch detailed information for a single sub‑community
 * identified by its immutable name. The underlying Prisma model is
 * community_platform_communities, which defines an owner via
 * community_platform_user_id, the display/URL name (name) and a normalized
 * case-insensitive uniqueness key (name_key), a single category, optional
 * description, and optional branding URIs (logo_uri, banner_uri). Timestamps
 * include created_at, updated_at, and an optional last_active_at for recent
 * activity displays. Records that have been removed from visibility are
 * excluded by the application using the deleted_at column.
 *
 * Security and Permissions: This read operation is public and requires no
 * authentication. Ownership does not affect read access; however, the
 * application may compute isOwner or isMember flags in the response for the
 * current session context using community_platform_users and
 * community_platform_community_members. Administrative overrides
 * (community_platform_siteadmins) affect write operations, not reads.
 *
 * Database Relationships: Community rules are stored in
 * community_platform_community_rules with order_index and text fields, and
 * posts in community_platform_posts. Both are associated via the community’s
 * id. Member counts derive from community_platform_community_members (distinct
 * user rows for the community), while the left sidebar “Recent Communities”
 * uses community_platform_recent_communities to record per-user
 * last_activity_at for up to five items.
 *
 * Validation and Business Logic: The path parameter communityName represents
 * the user-facing name (name). The server normalizes it to name_key to enforce
 * case-insensitive lookup, rejecting reserved names by business rule and
 * returning a not-found result when no active record exists (e.g., deleted_at
 * is set). The name is immutable after creation per requirements; this endpoint
 * never changes it.
 *
 * Related Operations and Usage: Use this endpoint to populate Community Home
 * (/c/[name]) and Post Detail sidebars. For the numbered “Community Rules”
 * section, clients typically call the rules listing endpoint to retrieve
 * ordered rule items limited to the top 5 by order_index.
 *
 * Error Handling: If the community does not exist or is not visible, return a
 * not-found response. Transient errors should use the platform’s standard
 * temporary error message, and clients may retry.
 *
 * @param props.connection
 * @param props.communityName Immutable community name used to locate the record
 *   (normalized to name_key for lookup).
 * @path /communityPlatform/communities/:communityName
 * @accessor api.functional.communityPlatform.communities.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /**
     * Immutable community name used to locate the record (normalized to
     * name_key for lookup).
     */
    communityName: string &
      tags.MinLength<3> &
      tags.MaxLength<30> &
      tags.Pattern<"^[A-Za-z0-9](?:[A-Za-z0-9_-]{1,28}[A-Za-z0-9])?$">;
  };
  export type Response = ICommunityPlatformCommunity;

  export const METADATA = {
    method: "GET",
    path: "/communityPlatform/communities/:communityName",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/communities/${encodeURIComponent(props.communityName ?? "null")}`;
  export const random = (): ICommunityPlatformCommunity =>
    typia.random<ICommunityPlatformCommunity>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityName")(() => typia.assert(props.communityName));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
