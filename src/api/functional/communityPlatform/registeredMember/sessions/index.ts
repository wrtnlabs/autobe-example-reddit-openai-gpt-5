import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformSession } from "../../../../structures/ICommunityPlatformSession";
import { IPageICommunityPlatformSession } from "../../../../structures/IPageICommunityPlatformSession";

/**
 * List authentication sessions for current user (community_platform_sessions).
 *
 * Retrieve a paginated list of the current user’s authentication sessions
 * sourced from the community_platform_sessions table. The schema defines core
 * columns used for session management and audit, including id (UUID),
 * community_platform_user_id, hashed_token (never exposed in plaintext),
 * user_agent, ip, client_platform, client_device, session_type, created_at,
 * updated_at, last_seen_at, expires_at, revoked_at, and deleted_at. Client UIs
 * typically show device hints and last activity while masking sensitive
 * internals.
 *
 * Security and permissions: access is restricted to authenticated users viewing
 * their own sessions. Provider logic must enforce that only sessions belonging
 * to the requester’s community_platform_user_id are returned. Revoked or
 * expired sessions may be excluded by default to align with a clean “active
 * sessions” view; administrative or troubleshooting tools can include them when
 * appropriate.
 *
 * Relationship to underlying entities: each session belongs to a
 * community_platform_users record via community_platform_user_id (onDelete:
 * Cascade). Listing sessions is often paired with endpoints to revoke a
 * specific session or to refresh the current one. Records where revoked_at is
 * not null or expires_at is reached should be treated as inactive; records
 * where deleted_at is not null are considered deactivated for retention reasons
 * and should be filtered from normal results.
 *
 * Validation and business rules: this index supports pagination using a cursor
 * derived from created_at and id (for deterministic Newest ordering) and may
 * support filtering by session_type, last_seen_at windows, or status (active vs
 * revoked/expired). Timestamps must be returned in ISO-8601 UTC. Sensitive
 * fields like hashed_token are never returned.
 *
 * Related operations: GET /sessions/{sessionId} returns an individual session
 * detail. Authentication refresh and sign-out flows are implemented elsewhere
 * and may leverage this listing for device/session management UIs. Error
 * handling should return a standardized 401 message when unauthenticated and
 * generic temporary error copy for transient failures.
 *
 * @param props.connection
 * @param props.body Search, filter, sort, and pagination criteria for listing
 *   the user’s sessions.
 * @path /communityPlatform/registeredMember/sessions
 * @accessor api.functional.communityPlatform.registeredMember.sessions.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search, filter, sort, and pagination criteria for listing the user’s
     * sessions.
     */
    body: ICommunityPlatformSession.IRequest;
  };
  export type Body = ICommunityPlatformSession.IRequest;
  export type Response = IPageICommunityPlatformSession.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/communityPlatform/registeredMember/sessions",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/communityPlatform/registeredMember/sessions";
  export const random = (): IPageICommunityPlatformSession.ISummary =>
    typia.random<IPageICommunityPlatformSession.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get a session by ID (community_platform_sessions).
 *
 * Fetch one session from community_platform_sessions using its id (UUID). The
 * table includes fields id, community_platform_user_id, hashed_token (hash
 * only), user_agent, ip, client_platform, client_device, session_type,
 * created_at, updated_at, last_seen_at, expires_at, revoked_at, and deleted_at.
 * Presentation should include device and timing metadata; never expose raw
 * tokens.
 *
 * Security: only authenticated users may call this endpoint, and only for
 * sessions associated with their own community_platform_user_id. Sessions where
 * revoked_at is set or expires_at is in the past are considered inactive and
 * may still be shown for history depending on product requirements; records
 * with deleted_at set are treated as deactivated and should not be returned in
 * normal flows.
 *
 * Behavior and errors: Return the full session view object for valid ownership
 * checks. If the identifier does not belong to the caller, respond with
 * authorization failure. Use ISO-8601 UTC timestamps and preserve exact stored
 * values for created_at, updated_at, last_seen_at, and expires_at. This detail
 * API is often used in concert with a revoke operation to invalidate a specific
 * session.
 *
 * @param props.connection
 * @param props.sessionId Target session’s ID (UUID) to retrieve
 * @path /communityPlatform/registeredMember/sessions/:sessionId
 * @accessor api.functional.communityPlatform.registeredMember.sessions.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Target session’s ID (UUID) to retrieve */
    sessionId: string & tags.Format<"uuid">;
  };
  export type Response = ICommunityPlatformSession;

  export const METADATA = {
    method: "GET",
    path: "/communityPlatform/registeredMember/sessions/:sessionId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/registeredMember/sessions/${encodeURIComponent(props.sessionId ?? "null")}`;
  export const random = (): ICommunityPlatformSession =>
    typia.random<ICommunityPlatformSession>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("sessionId")(() => typia.assert(props.sessionId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
