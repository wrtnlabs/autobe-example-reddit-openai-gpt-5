import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformPost } from "../../../../structures/ICommunityPlatformPost";
export * as comments from "./comments/index";
export * as vote from "./vote/index";

/**
 * Create a text-only post (community_platform_posts) under a resolved
 * community.
 *
 * This operation inserts a new row into community_platform_posts with foreign
 * keys to community_platform_users (author) and community_platform_communities
 * (target community). The community is resolved from the client-supplied
 * community identity (e.g., name mapped to name_key for case-insensitive
 * lookup). The posts table stores title and body as plain text and an optional
 * author_display_name for presentation, along with created_at/updated_at
 * timestamps used for Newest ordering and relative time displays across the
 * product.
 *
 * Security and permissions require authentication. Posting does not require the
 * user to be a member of the target community, but authorship and subsequent
 * edit/delete ownership checks derive from community_platform_user_id.
 * Providers must validate required input ranges as per business rules—title
 * between 5 and 120 characters; body between 10 and 10,000 characters; author
 * display name up to 32 characters—and must ensure that a valid community
 * exists; otherwise, creation is rejected with appropriate error messaging.
 *
 * Related behaviors include updating the community’s last_active_at for
 * freshness and enabling downstream lists (Home/Community feeds, Global Latest)
 * to surface the content under the defined deterministic sorts. On success, the
 * endpoint returns the created entity ICommunityPlatformPost that includes
 * identifiers and display-ready fields used by clients to render cards or
 * detail views immediately after submission.
 *
 * @param props.connection
 * @param props.body New post data (community, title, body, optional author
 *   display name).
 * @path /communityPlatform/registeredMember/posts
 * @accessor api.functional.communityPlatform.registeredMember.posts.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** New post data (community, title, body, optional author display name). */
    body: ICommunityPlatformPost.ICreate;
  };
  export type Body = ICommunityPlatformPost.ICreate;
  export type Response = ICommunityPlatformPost;

  export const METADATA = {
    method: "POST",
    path: "/communityPlatform/registeredMember/posts",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/communityPlatform/registeredMember/posts";
  export const random = (): ICommunityPlatformPost =>
    typia.random<ICommunityPlatformPost>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a post in community_platform_posts (title/body/display name) with
 * ownership checks.
 *
 * Purpose and overview: Update a text-only post the user previously authored.
 * The underlying Prisma model is community_platform_posts with columns: id
 * (UUID, PK), community_platform_community_id (FK), community_platform_user_id
 * (FK), title, body, author_display_name (nullable), created_at, updated_at,
 * and deleted_at (nullable). Clients use this operation to change
 * title/body/author_display_name only. The owning community reference and
 * author linkage remain unchanged to respect business immutability. On success,
 * updated_at reflects the modification time and the updated post is returned.
 *
 * Security and permissions: Only the post’s author may edit, with a possible
 * administrative override handled by business logic. Implementations must
 * verify the caller maps to community_platform_posts.community_platform_user_id
 * and deny others with the standard author-guard message. Although membership
 * is not required to post, ownership is required to edit. Attempts from
 * unauthenticated users should be rejected with the standard login-required
 * message.
 *
 * Database relationships: The post belongs to a community via
 * community_platform_community_id and to a user via community_platform_user_id.
 * Voting state is stored in community_platform_post_votes and comment threads
 * in community_platform_comments; these related tables supply derived fields
 * like score or comment counts to clients but are not directly mutated by this
 * update. The record must not be edited when deleted_at is non-null; such posts
 * are excluded from normal operations.
 *
 * Validation and business rules: Enforce title length 5–120 and body length
 * 10–10,000 (plain text with line breaks, no executable content). Enforce
 * author_display_name length 0–32 when provided. The target community is
 * immutable and cannot be changed by this operation. The identifier and
 * created_at are immutable. Inputs contrary to these rules should be rejected
 * with appropriate 400 errors and standard messages.
 *
 * Related operations: Use GET post detail to read a single post, DELETE to
 * remove it from public visibility, list endpoints to fetch feeds, and comment
 * endpoints for threaded discussions. Error handling includes 401 for
 * unauthenticated users, 403 for non-owners, 404 if the post does not exist or
 * is no longer visible, and 503/500 for temporary failures.
 *
 * @param props.connection
 * @param props.postId Target post identifier (UUID) to update
 * @param props.body Fields to modify for the post; community and author are
 *   immutable
 * @path /communityPlatform/registeredMember/posts/:postId
 * @accessor api.functional.communityPlatform.registeredMember.posts.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Target post identifier (UUID) to update */
    postId: string & tags.Format<"uuid">;

    /** Fields to modify for the post; community and author are immutable */
    body: ICommunityPlatformPost.IUpdate;
  };
  export type Body = ICommunityPlatformPost.IUpdate;
  export type Response = ICommunityPlatformPost;

  export const METADATA = {
    method: "PUT",
    path: "/communityPlatform/registeredMember/posts/:postId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPlatform/registeredMember/posts/${encodeURIComponent(props.postId ?? "null")}`;
  export const random = (): ICommunityPlatformPost =>
    typia.random<ICommunityPlatformPost>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete a post in community_platform_posts by marking deleted_at and removing
 * it from public views.
 *
 * Purpose and overview: Delete an existing post so it no longer appears on Home
 * feeds, community lists, search, or post detail. This operation targets the
 * community_platform_posts table which defines columns id,
 * community_platform_community_id, community_platform_user_id, title, body,
 * author_display_name, created_at, updated_at, and deleted_at. Deletion sets
 * deleted_at to the current time to ensure the record is treated as removed
 * from public views.
 *
 * Security and permissions: Only the post’s author is allowed to delete, with a
 * business-level administrative override possible. Implementations must enforce
 * ownership by matching the authenticated user to community_platform_user_id
 * for the post. Unauthenticated requests should result in a login-required
 * response; non-owners receive an author-guard denial.
 *
 * Relationships and effects: The post has relationships to
 * community_platform_comments and community_platform_post_votes. After
 * deletion, further interactions (comments, votes) must be blocked. Clients
 * should not surface the post in feeds or detail views when deleted_at is
 * present. If application logic performs cascaded cleanup, it must preserve
 * referential integrity; however, the primary behavior is to mark the post as
 * deleted and exclude it from reads.
 *
 * Validation and error handling: Return 404 if the post does not exist or has
 * already been marked as deleted. Use 401 for unauthenticated access and 403
 * for non-owner attempts. Temporary errors should surface a retryable message.
 *
 * @param props.connection
 * @param props.postId Target post identifier (UUID) to delete
 * @path /communityPlatform/registeredMember/posts/:postId
 * @accessor api.functional.communityPlatform.registeredMember.posts.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Target post identifier (UUID) to delete */
    postId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/communityPlatform/registeredMember/posts/:postId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/registeredMember/posts/${encodeURIComponent(props.postId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
