import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformCommunityMember } from "../../../../../structures/ICommunityPlatformCommunityMember";

/**
 * List a user’s current community memberships from
 * community_platform_community_members.
 *
 * Return the list of communities a user is currently joined to. The Prisma
 * model community_platform_community_members links users
 * (community_platform_users.id) to communities
 * (community_platform_communities.id) and records created_at and updated_at
 * timestamps. This operation filters by the path parameter {userId} and
 * includes only visible memberships (deleted_at is null) and communities that
 * are still visible.
 *
 * Security considerations: Authorization requires an authenticated session. The
 * provider should enforce that the requesting user matches {userId} for
 * privacy, or apply elevated privileges in administrative contexts per policy.
 * This documentation assigns the generic “registeredMember” role and expects
 * ownership enforcement in provider logic.
 *
 * Relationships and data shape: Each returned membership references the
 * community entity for fields such as name, description, logo_uri, and
 * category. Member count shown in cards, if included, should be computed from
 * active rows in community_platform_community_members for the referenced
 * community.
 *
 * Validation rules and business logic: The path parameter {userId} must be a
 * valid UUID present in community_platform_users. Records with a non-null
 * deleted_at are not returned. Timestamps should be emitted in ISO-8601 UTC
 * format.
 *
 * Related operations: /me/recentCommunities for the recency-based list, and PUT
 * /communities/{communityName}/membership to toggle membership. Community
 * discovery is handled by /communities endpoints.
 *
 * Error handling: Unauthenticated access should result in an authorization
 * error with standardized copy. If the user id does not exist, return
 * not-found; temporary issues should surface the standardized temporary error.
 *
 * @param props.connection
 * @param props.userId Target user’s ID (community_platform_users.id).
 * @path /communityPlatform/registeredMember/users/:userId/memberships
 * @accessor api.functional.communityPlatform.registeredMember.users.memberships.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
      );
}
export namespace index {
  export type Props = {
    /** Target user’s ID (community_platform_users.id). */
    userId: string & tags.Format<"uuid">;
  };
  export type Response = ICommunityPlatformCommunityMember.IList;

  export const METADATA = {
    method: "GET",
    path: "/communityPlatform/registeredMember/users/:userId/memberships",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/registeredMember/users/${encodeURIComponent(props.userId ?? "null")}/memberships`;
  export const random = (): ICommunityPlatformCommunityMember.IList =>
    typia.random<ICommunityPlatformCommunityMember.IList>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
