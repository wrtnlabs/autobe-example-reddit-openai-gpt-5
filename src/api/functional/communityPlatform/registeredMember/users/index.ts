import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformUser } from "../../../../structures/ICommunityPlatformUser";
export * as memberships from "./memberships/index";

/**
 * Get a single account detail from community_platform_users by ID.
 *
 * Return one user account record from the Prisma model community_platform_users
 * identified by id. The model contains id, email, email_normalized, username,
 * username_normalized, password_hash, display_name?, last_login_at?,
 * created_at, updated_at, and deleted_at?. Per schema comments,
 * email_normalized and username_normalized enforce case-insensitive uniqueness;
 * they are internal and should not be exposed. The password_hash column is
 * strictly confidential and must never appear in responses.
 *
 * Security and permissions: Any authenticated user may retrieve only their own
 * account; enforcement occurs in provider logic by comparing the path userId to
 * the authenticated principal. Site administrators may be allowed to read any
 * account according to policy. Soft-deleted accounts (deleted_at set) should
 * typically be inaccessible to regular users unless policy requires otherwise.
 *
 * Relationships and context: Although a user is related to sessions, role
 * flags, communities, posts, comments, and votes, this endpoint focuses on the
 * primary account entity. Additional aggregates or flags (e.g., isSiteAdmin)
 * may be computed by looking up rows in community_platform_siteadmins and
 * community_platform_registeredmembers.
 *
 * Validation and errors: The path parameter userId must be a valid UUID. If the
 * record does not exist or is not accessible to the caller, return a not-found
 * or permission-denied error consistent with platform standards. Temporary
 * errors should produce the standard recoverable message for clients.
 *
 * @param props.connection
 * @param props.userId Target user’s unique identifier (UUID)
 * @path /communityPlatform/registeredMember/users/:userId
 * @accessor api.functional.communityPlatform.registeredMember.users.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Target user’s unique identifier (UUID) */
    userId: string & tags.Format<"uuid">;
  };
  export type Response = ICommunityPlatformUser;

  export const METADATA = {
    method: "GET",
    path: "/communityPlatform/registeredMember/users/:userId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/registeredMember/users/${encodeURIComponent(props.userId ?? "null")}`;
  export const random = (): ICommunityPlatformUser =>
    typia.random<ICommunityPlatformUser>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a user profile in community_platform_users by ID.
 *
 * Modify an existing user record in Prisma model community_platform_users
 * addressed by id. The table contains id, email, email_normalized, username,
 * username_normalized, password_hash, optional display_name, last_login_at,
 * created_at, updated_at, and optional deleted_at. Based on schema comments,
 * normalized columns enforce CI uniqueness; when updating email or username,
 * the application should compute and persist the normalized forms consistently
 * while validating uniqueness.
 *
 * Security and permissions: Only the account owner should be allowed to update
 * their own profile fields under normal policy; a site administrator may
 * override when necessary for compliance. This API must ignore attempts to
 * modify password_hash and never echo it back. It must also prevent updates to
 * immutable identifiers such as id and to server-managed timestamps
 * (created_at, updated_at) except for system logic.
 *
 * Relationships and constraints: This operation does not directly manipulate
 * sessions, role assignment tables, or content authored by the user. If
 * username/email changes are permitted, ensure downstream references and caches
 * reconcile appropriately. Soft-deleted users (deleted_at set) should be
 * considered inactive/uneditable unless reactivation is implemented
 * separately.
 *
 * Error handling: Validate UUID format for userId. Enforce email/username
 * case-insensitive uniqueness; on conflict return 409 with a suitable message.
 * For forbidden ownership cases, return 403. On transient failures, return the
 * standard temporary error message.
 *
 * @param props.connection
 * @param props.userId Target user’s unique identifier (UUID)
 * @param props.body Fields to update for the user profile (e.g., display_name,
 *   optional username/email per policy)
 * @path /communityPlatform/registeredMember/users/:userId
 * @accessor api.functional.communityPlatform.registeredMember.users.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Target user’s unique identifier (UUID) */
    userId: string & tags.Format<"uuid">;

    /**
     * Fields to update for the user profile (e.g., display_name, optional
     * username/email per policy)
     */
    body: ICommunityPlatformUser.IUpdate;
  };
  export type Body = ICommunityPlatformUser.IUpdate;
  export type Response = ICommunityPlatformUser;

  export const METADATA = {
    method: "PUT",
    path: "/communityPlatform/registeredMember/users/:userId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPlatform/registeredMember/users/${encodeURIComponent(props.userId ?? "null")}`;
  export const random = (): ICommunityPlatformUser =>
    typia.random<ICommunityPlatformUser>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Deactivate a user (set deleted_at) in community_platform_users by ID.
 *
 * Permanently remove a user account from normal visibility by marking it as
 * deleted in the community_platform_users table. The Prisma schema defines
 * deleted_at as an optional timestamp, enabling a soft deletion pattern. This
 * operation should set deleted_at to the current timestamp to deactivate the
 * account without dropping related records. The record will be excluded from
 * standard queries unless explicitly included for compliance.
 *
 * Security and permissions: Typically, an authenticated user may request
 * deactivation for their own account, and a site administrator may deactivate
 * any account when required for policy/legal reasons. Business logic must
 * verify authority before proceeding. After deactivation, existing sessions
 * should be revoked via community_platform_sessions according to policy, and
 * write actions must be blocked for the deactivated account.
 *
 * Relationships and behavior: Content authored by the user (communities, posts,
 * comments, votes) remains in place per platform policy; this API does not
 * cascade hard deletions. If additional cleanup is required, perform it in
 * service logic while maintaining auditability. To reverse deactivation,
 * implement a separate restore process that clears deleted_at under strict
 * authorization.
 *
 * Error handling: Validate userId as UUID. If the account is already
 * deactivated (deleted_at not null), the operation may be idempotent. On
 * success, return 204 No Content with no response body. For forbidden actions,
 * return 403. For transient errors, surface the standard temporary error
 * message.
 *
 * @param props.connection
 * @param props.userId Target user’s unique identifier (UUID)
 * @path /communityPlatform/registeredMember/users/:userId
 * @accessor api.functional.communityPlatform.registeredMember.users.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Target user’s unique identifier (UUID) */
    userId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/communityPlatform/registeredMember/users/:userId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/registeredMember/users/${encodeURIComponent(props.userId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
