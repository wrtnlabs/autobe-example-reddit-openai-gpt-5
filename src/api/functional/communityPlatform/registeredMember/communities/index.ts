import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformCommunity } from "../../../../structures/ICommunityPlatformCommunity";
export * as rules from "./rules/index";
export * as membership from "./membership/index";

/**
 * Create a community (community_platform_communities).
 *
 * This operation creates a community backed by the
 * community_platform_communities table. Fields include name (immutable at the
 * application level), name_key (lowercased/normalized for uniqueness), category
 * (single selection), optional description, logo_uri, banner_uri, and
 * timestamps created_at/updated_at. The creator is stored in
 * community_platform_user_id with a relation to community_platform_users. If
 * rules are provided, they are stored in community_platform_community_rules
 * with order_index and text, linked via community_platform_community_id.
 *
 * Security and permissions: creation requires authentication. Only the
 * authenticated user is set as creator (community_platform_user_id). After
 * creation, business logic may insert a membership row into
 * community_platform_community_members for the creator so the community appears
 * in personalized feeds and counts; member counts are computed from membership
 * rows where deleted_at is null.
 *
 * Validation and business rules: enforce name formatting and case-insensitive
 * uniqueness (name_key). The name is immutable after creation; category must be
 * selected from the allowed set at the application level. Optional branding
 * URIs (logo_uri, banner_uri) can be stored as URI strings. Records with
 * deleted_at set are considered inactive and should not be created through this
 * API; instead, create only active communities. On success, return the full
 * community representation, including timestamps and any initial rules
 * created.
 *
 * Related operations: community discovery via PATCH /communities and community
 * detail retrieval endpoints (not shown here) commonly follow creation. Error
 * handling returns standardized messages for name conflicts and invalid name
 * formats, with generic temporary error copy for transient failures.
 *
 * @param props.connection
 * @param props.body Community creation payload including immutable name,
 *   category, optional description/branding, and optional initial rules.
 * @path /communityPlatform/registeredMember/communities
 * @accessor api.functional.communityPlatform.registeredMember.communities.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Community creation payload including immutable name, category,
     * optional description/branding, and optional initial rules.
     */
    body: ICommunityPlatformCommunity.ICreate;
  };
  export type Body = ICommunityPlatformCommunity.ICreate;
  export type Response = ICommunityPlatformCommunity;

  export const METADATA = {
    method: "POST",
    path: "/communityPlatform/registeredMember/communities",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/communityPlatform/registeredMember/communities";
  export const random = (): ICommunityPlatformCommunity =>
    typia.random<ICommunityPlatformCommunity>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update community metadata in community_platform_communities (name immutable).
 *
 * Purpose and Overview: This operation updates a community’s mutable metadata
 * in community_platform_communities. The model defines name (immutable at the
 * application layer) and name_key (normalized CI uniqueness). Other columns
 * include category (single value), optional description, optional logo_uri and
 * banner_uri, last_active_at (optional), and standard timestamps (created_at,
 * updated_at). The update targets description, logo_uri, banner_uri, and
 * category; it never changes name or name_key.
 *
 * Security and Permissions: Authentication is required (registered member).
 * Only the creator (matched via community_platform_user_id) or a site
 * administrator (recorded in community_platform_siteadmins) may perform this
 * update. Authorization is enforced in business logic; unauthorized requests
 * must be rejected with the platform’s standard ownership message. This
 * endpoint is restricted to metadata editing and does not grant moderation
 * rights through membership.
 *
 * Database and Relationships: The target record is located by normalizing the
 * path communityName to name_key. The community remains linked to rule items in
 * community_platform_community_rules, memberships in
 * community_platform_community_members, and posts in community_platform_posts.
 * Editing metadata does not affect those relationships. The updated_at field
 * should reflect the modification time; last_active_at is typically maintained
 * by activity signals (e.g., posting/commenting) rather than by this endpoint.
 *
 * Validation and Business Logic: Input values must respect business rules:
 * category must be chosen from the fixed set defined by requirements;
 * description length (≤ 500 chars) should be enforced application-side;
 * logo_uri and banner_uri are string URIs. The record must be active
 * (deleted_at null) and identifiable by name_key. Name immutability is
 * enforced; attempts to rename are invalid.
 *
 * Related Operations and Usage: Combine with GET /communities/{communityName}
 * to fetch current values and with the rules listing endpoint to manage or
 * display rules. Deletion (DELETE /communities/{communityName}) permanently
 * removes the community and its dependent data.
 *
 * Error Handling: Unauthorized callers receive a forbidden response with the
 * standard copy. Nonexistent or removed communities return not-found. Invalid
 * inputs yield bad-request with clear messages. Transient issues return the
 * platform’s standard temporary error message.
 *
 * @param props.connection
 * @param props.communityName Immutable community name identifying the target
 *   community (normalized to name_key).
 * @param props.body Fields to update for the community (description, logoUri,
 *   bannerUri, category).
 * @path /communityPlatform/registeredMember/communities/:communityName
 * @accessor api.functional.communityPlatform.registeredMember.communities.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /**
     * Immutable community name identifying the target community (normalized
     * to name_key).
     */
    communityName: string &
      tags.MinLength<3> &
      tags.MaxLength<30> &
      tags.Pattern<"^[A-Za-z0-9](?:[A-Za-z0-9_-]{1,28}[A-Za-z0-9])?$">;

    /**
     * Fields to update for the community (description, logoUri, bannerUri,
     * category).
     */
    body: ICommunityPlatformCommunity.IUpdate;
  };
  export type Body = ICommunityPlatformCommunity.IUpdate;
  export type Response = ICommunityPlatformCommunity;

  export const METADATA = {
    method: "PUT",
    path: "/communityPlatform/registeredMember/communities/:communityName",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPlatform/registeredMember/communities/${encodeURIComponent(props.communityName ?? "null")}`;
  export const random = (): ICommunityPlatformCommunity =>
    typia.random<ICommunityPlatformCommunity>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityName")(() => typia.assert(props.communityName));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete a community (hard delete) from community_platform_communities and
 * cascade dependent data.
 *
 * Purpose and Overview: Remove a community and all associated data from
 * user-visible surfaces by deleting the record in
 * community_platform_communities. The model includes name (immutable), name_key
 * (normalized uniqueness), category, description, branding URIs, activity
 * timestamps, and standard auditing timestamps. This operation performs a hard
 * delete: records are completely removed and cannot be recovered.
 *
 * Security and Permissions: Only the creator (matched via
 * community_platform_user_id) or a site administrator may perform the deletion.
 * Authentication as a registered member is required; business logic must
 * enforce ownership checks and administrative overrides using
 * community_platform_siteadmins. Non-owners must receive the standard ownership
 * denial message.
 *
 * Relationship and Cascade Behavior: Deleting a community cascades to related
 * data: posts in community_platform_posts (and their votes/comments), community
 * rules in community_platform_community_rules, memberships in
 * community_platform_community_members, and recent entries in
 * community_platform_recent_communities are removed via relational onDelete:
 * Cascade definitions. From a user perspective, the deletion appears atomic;
 * after success, the community and its posts no longer appear in feeds, search,
 * or sidebars.
 *
 * Validation and Business Logic: The target is located by normalizing
 * communityName to name_key. If the community cannot be found, return
 * not-found. Once deletion succeeds, the name may be reusable per business
 * policy since the prior record is gone. Because this is a permanent removal,
 * clients should confirm destructive intent before invoking.
 *
 * Related Operations and Usage: Use GET /communities/{communityName} to verify
 * the target before deletion. After deletion, subsequent reads of the same name
 * must return not-found. For metadata edits instead of removal, use PUT
 * /communities/{communityName}.
 *
 * Error Handling: Unauthorized requests are forbidden with the platform’s
 * standard copy. Nonexistent targets return not-found. Transient failures use
 * the standard temporary error message. Successful deletion returns no
 * content.
 *
 * @param props.connection
 * @param props.communityName Immutable community name identifying the target to
 *   remove (normalized to name_key).
 * @path /communityPlatform/registeredMember/communities/:communityName
 * @accessor api.functional.communityPlatform.registeredMember.communities.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /**
     * Immutable community name identifying the target to remove (normalized
     * to name_key).
     */
    communityName: string &
      tags.MinLength<3> &
      tags.MaxLength<30> &
      tags.Pattern<"^[A-Za-z0-9](?:[A-Za-z0-9_-]{1,28}[A-Za-z0-9])?$">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/communityPlatform/registeredMember/communities/:communityName",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/registeredMember/communities/${encodeURIComponent(props.communityName ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityName")(() => typia.assert(props.communityName));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
