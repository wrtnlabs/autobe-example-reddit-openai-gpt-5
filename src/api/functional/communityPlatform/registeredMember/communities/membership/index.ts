import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformCommunityMember } from "../../../../../structures/ICommunityPlatformCommunityMember";

/**
 * Update current user’s community membership via
 * community_platform_community_members.
 *
 * Update the calling user’s membership in a specific community. The Prisma
 * schema models communities with community_platform_communities, including
 * immutable name, name_key for case-insensitive uniqueness, and timestamps like
 * created_at and last_active_at. Memberships are represented by
 * community_platform_community_members with references to users and
 * communities, and include created_at/updated_at timestamps and a deleted_at
 * column that should be respected by queries.
 *
 * Security and permissions: Authentication is required. Any registered member
 * may join or leave a community. Joining does not convey moderation privileges.
 * Ownership checks are not required beyond validating the acting user’s
 * identity.
 *
 * Validation and business logic: Resolve the community using {communityName}
 * (normalize to name_key). If the body indicates join=true and no active
 * membership exists, insert a row and set created_at. If a historical row
 * exists that is not considered active, reactivate it by clearing removal
 * markers and updating updated_at. If join=false and an active membership
 * exists, remove it from active consideration so that it no longer appears in
 * membership queries that require deleted_at to be null. Update
 * community_platform_recent_communities.last_activity_at for the caller to
 * ensure the Left Sidebar reflects the latest state. Compute and return the
 * current memberCount as the number of active membership rows for the
 * community.
 *
 * Related operations: /me/recentCommunities for recency display; GET
 * /communities/{communityName} for community details; and the user memberships
 * listing endpoint. This write is idempotent relative to the intended final
 * state.
 *
 * Error handling: If unauthenticated, return an authorization error aligned
 * with standardized copy. If the target community does not exist or is not
 * visible, return not-found. Temporary failures should return the standardized
 * temporary error and no partial state should be exposed to clients.
 *
 * @param props.connection
 * @param props.communityName Immutable community name used to resolve the
 *   target community (application normalizes to name_key).
 * @param props.body Desired membership state payload, e.g., { join: true } to
 *   join or { join: false } to leave.
 * @path /communityPlatform/registeredMember/communities/:communityName/membership
 * @accessor api.functional.communityPlatform.registeredMember.communities.membership.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /**
     * Immutable community name used to resolve the target community
     * (application normalizes to name_key).
     */
    communityName: string &
      tags.MinLength<3> &
      tags.MaxLength<30> &
      tags.Pattern<"^[A-Za-z0-9](?:[A-Za-z0-9_-]*[A-Za-z0-9])$">;

    /**
     * Desired membership state payload, e.g., { join: true } to join or {
     * join: false } to leave.
     */
    body: ICommunityPlatformCommunityMember.IUpdate;
  };
  export type Body = ICommunityPlatformCommunityMember.IUpdate;
  export type Response = ICommunityPlatformCommunityMember;

  export const METADATA = {
    method: "PUT",
    path: "/communityPlatform/registeredMember/communities/:communityName/membership",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPlatform/registeredMember/communities/${encodeURIComponent(props.communityName ?? "null")}/membership`;
  export const random = (): ICommunityPlatformCommunityMember =>
    typia.random<ICommunityPlatformCommunityMember>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityName")(() => typia.assert(props.communityName));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Leave a community by deleting the caller’s membership row
 * (community_platform_community_members).
 *
 * This endpoint removes the authenticated user’s membership link to a target
 * community. The relationship is stored in the
 * community_platform_community_members table, which contains foreign keys to
 * community_platform_users (as the joining account) and
 * community_platform_communities (as the target community). The community is
 * resolved by the provided communityName path parameter, which maps to the
 * immutable name field and its normalized name_key for case-insensitive
 * uniqueness. The membership table enforces a unique constraint on
 * [community_platform_user_id, community_platform_community_id], ensuring a
 * single row represents membership and enabling idempotent join/leave
 * semantics.
 *
 * Security and permissions follow the business rules that joining and leaving
 * communities require authentication. Only the currently authenticated account
 * may create or remove its own membership rows. Administrative roles are not
 * required for this operation, and leaving a community never alters moderation
 * or ownership rights. The controller/provider resolves the caller from the
 * session and executes the deletion against the appropriate membership row when
 * present.
 *
 * From a data and relationship standpoint, removal of the membership may
 * influence personalization features such as the Home feed (which is derived
 * from joined communities) and can update auxiliary records like
 * community_platform_recent_communities for last-activity ordering. Community
 * existence is validated against community_platform_communities; if the
 * community name does not resolve, the operation fails with a not-found
 * outcome. If the user is not currently a member, the operation is effectively
 * a no-op but still succeeds to preserve idempotence and responsive UI flows.
 *
 * Error handling and behavior expectations: the operation returns no response
 * body on success. Providers should implement standard error mappings (e.g.,
 * 401 when unauthenticated) and may return a not-found error when the community
 * cannot be resolved by name. Rate limiting may be applied to protect service
 * stability during bursts of toggling. The underlying foreign key relations in
 * community_platform_community_members use Cascade delete toward both the user
 * and community entities, but this endpoint itself performs a straightforward
 * membership unlink for the current user.
 *
 * @param props.connection
 * @param props.communityName Immutable community name used to resolve the
 *   target community.
 * @path /communityPlatform/registeredMember/communities/:communityName/membership
 * @accessor api.functional.communityPlatform.registeredMember.communities.membership.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Immutable community name used to resolve the target community. */
    communityName: string;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/communityPlatform/registeredMember/communities/:communityName/membership",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/registeredMember/communities/${encodeURIComponent(props.communityName ?? "null")}/membership`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityName")(() => typia.assert(props.communityName));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
