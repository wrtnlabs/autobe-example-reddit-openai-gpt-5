import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformPost } from "../../../structures/ICommunityPlatformPost";
import { IPageICommunityPlatformPost } from "../../../structures/IPageICommunityPlatformPost";
export * as comments from "./comments/index";
export * as history from "./history/index";

/**
 * List/search posts (community_platform_posts) with pagination and sorting.
 *
 * Return a filtered, paginated list of posts using the community_platform_posts
 * entity as the primary source. The Prisma schema includes trigram indexes on
 * title and body to support efficient text matching. Business constraints from
 * the requirements define the search and sorting behavior: queries match words
 * in titles and bodies; sorting supports Newest (order by created_at
 * descending; if equal, larger identifier first) and Top (order by score
 * derived from community_platform_post_votes as up−down; ties by more recent
 * created_at, then by larger identifier). Items not publicly accessible
 * (records with non-null deleted_at) are excluded from results.
 *
 * Security and access: Reading posts is allowed for all users, including
 * guests. This endpoint is public and does not require authentication.
 * Sensitive author information is not exposed beyond what is stored for
 * presentation (e.g., author_display_name). Ownership rules do not limit read
 * access.
 *
 * Data model and relationships: Each post belongs to one community
 * (community_platform_communities) and optionally references an author
 * (community_platform_users, nullable to support anonymization). Votes are
 * stored in community_platform_post_votes and may be aggregated for Top
 * sorting. The request body (ICommunityPlatformPost.IRequest) should include
 * pagination controls, optional community filter, search query (length ≥ 2
 * characters to execute), and sort selector. The response returns a paginated
 * page of post summaries suitable for feeds and result lists.
 *
 * Related endpoints: Use GET /communityPlatform/posts/{postId} to retrieve a
 * specific post. Use POST /communityPlatform/communityMember/posts or POST
 * /communityPlatform/communityMember/communities/{communityId}/posts for
 * creation flows.
 *
 * @param props.connection
 * @param props.body Search, filter, sort, and pagination parameters for posts
 * @path /communityPlatform/posts
 * @accessor api.functional.communityPlatform.posts.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Search, filter, sort, and pagination parameters for posts */
    body: ICommunityPlatformPost.IRequest;
  };
  export type Body = ICommunityPlatformPost.IRequest;
  export type Response = IPageICommunityPlatformPost.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/communityPlatform/posts",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/communityPlatform/posts";
  export const random = (): IPageICommunityPlatformPost.ISummary =>
    typia.random<IPageICommunityPlatformPost.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get a single post (community_platform_posts) by ID.
 *
 * Retrieve a single post resource from community_platform_posts by its ID.
 * According to the Prisma schema, posts have required title and body, optional
 * author_display_name, belong to a community (community_platform_community_id),
 * and may have a nullable author_user_id (to support anonymization). The
 * operation returns full details for display in post detail screens.
 *
 * Security and permissions: This is a public read operation; no authentication
 * is required. Records that are not publicly accessible (e.g., where deleted_at
 * is set) are not returned. Ownership constraints do not affect reads here, but
 * apply to updates/deletes via separate endpoints.
 *
 * Data relationships and behavior: The post references
 * community_platform_communities and community_platform_users (author). Voting
 * and comments are separate entities and not directly altered by this read. For
 * Global Latest sidebar behavior or aggregated counters, clients may rely on
 * separate materialized views or related endpoints as needed.
 *
 * Related endpoints: Use PATCH /communityPlatform/posts for listing/searching
 * posts with pagination. Use POST /communityPlatform/communityMember/posts or
 * POST /communityPlatform/communityMember/communities/{communityId}/posts for
 * creation flows.
 *
 * @param props.connection
 * @param props.postId Unique identifier of the target post (UUID)
 * @path /communityPlatform/posts/:postId
 * @accessor api.functional.communityPlatform.posts.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the target post (UUID) */
    postId: string & tags.Format<"uuid">;
  };
  export type Response = ICommunityPlatformPost;

  export const METADATA = {
    method: "GET",
    path: "/communityPlatform/posts/:postId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/posts/${encodeURIComponent(props.postId ?? "null")}`;
  export const random = (): ICommunityPlatformPost =>
    typia.random<ICommunityPlatformPost>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
