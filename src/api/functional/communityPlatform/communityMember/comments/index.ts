import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformComment } from "../../../../structures/ICommunityPlatformComment";
export * as replies from "./replies/index";
export * as votes from "./votes/index";

/**
 * Update a comment (community_platform_comments) by ID.
 *
 * Edit an existing comment identified by commentId in the
 * community_platform_comments table. The underlying Prisma model defines key
 * columns such as content (plain text, business rule 2–2,000 characters),
 * community_platform_user_id (author), community_platform_post_id (container
 * post), optional parent_id for nested replies, and lifecycle timestamps
 * (created_at, updated_at, deleted_at). The API updates mutable fields
 * (typically content) and sets updated_at, maintaining the integrity of
 * authorship and thread structure.
 *
 * Security and permissions follow the product rules: only the author of a
 * comment may edit it. Attempts by non-authors must be denied with the standard
 * message, and unauthenticated users must be required to sign in prior to
 * state-changing actions. The operation requires an authenticated session (role
 * "communityMember") with ownership verified in business logic.
 *
 * The operation works in the context of related entities: comments belong to
 * posts (community_platform_posts) and may reference a parent comment via
 * parent_id for nested threading. Business validation must ensure the target
 * comment exists and is not already marked removed via deleted_at. Content
 * length constraints (2–2,000) and plain-text expectations are enforced at the
 * application level per the model commentary.
 *
 * Related operations include creating a reply under a comment and listing
 * replies. Error handling should provide clear responses when the comment is
 * not found, when the actor lacks ownership, or when validation fails. Updated
 * entities are returned as ICommunityPlatformComment for client reconciliation
 * and optimistic UI confirmation.
 *
 * @param props.connection
 * @param props.commentId Target comment's ID (UUID) to update
 * @param props.body Editable fields of the comment to update (e.g., content)
 * @path /communityPlatform/communityMember/comments/:commentId
 * @accessor api.functional.communityPlatform.communityMember.comments.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Target comment's ID (UUID) to update */
    commentId: string & tags.Format<"uuid">;

    /** Editable fields of the comment to update (e.g., content) */
    body: ICommunityPlatformComment.IUpdate;
  };
  export type Body = ICommunityPlatformComment.IUpdate;
  export type Response = ICommunityPlatformComment;

  export const METADATA = {
    method: "PUT",
    path: "/communityPlatform/communityMember/comments/:commentId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPlatform/communityMember/comments/${encodeURIComponent(props.commentId ?? "null")}`;
  export const random = (): ICommunityPlatformComment =>
    typia.random<ICommunityPlatformComment>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("commentId")(() => typia.assert(props.commentId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete a comment (community_platform_comments) by ID by setting deleted_at.
 *
 * Delete a comment by its identifier in the community_platform_comments table
 * by marking it removed via the deleted_at timestamp. The Prisma model
 * explicitly includes deleted_at (nullable) for comments, which indicates
 * records can be marked as removed from public view without erasing historical
 * data. The operation should ensure the comment exists, is not already removed,
 * and that the actor is the author (or otherwise authorized) before
 * proceeding.
 *
 * Security and permissions require that only the comment author can delete
 * their own comment under normal operations. Unauthenticated requests must be
 * blocked and prompted to sign in. Administrative removals, if implemented
 * elsewhere, are outside the scope of this endpoint and should be captured in
 * separate policy functions and audit trails.
 *
 * The comment is linked to a post (community_platform_posts) and may have a
 * parent comment via parent_id for nesting. When marking the comment as
 * removed, application logic should update updated_at accordingly and ensure
 * reply-thread integrity for remaining comments. Errors include missing or
 * already-removed comments and permission denials. On success, no response body
 * is returned, and clients should reconcile their view accordingly.
 *
 * @param props.connection
 * @param props.commentId Target comment's ID (UUID) to delete
 * @path /communityPlatform/communityMember/comments/:commentId
 * @accessor api.functional.communityPlatform.communityMember.comments.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Target comment's ID (UUID) to delete */
    commentId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/communityPlatform/communityMember/comments/:commentId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/communityMember/comments/${encodeURIComponent(props.commentId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("commentId")(() => typia.assert(props.commentId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
