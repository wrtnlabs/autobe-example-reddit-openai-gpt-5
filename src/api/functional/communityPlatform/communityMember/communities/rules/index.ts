import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformCommunityRule } from "../../../../../structures/ICommunityPlatformCommunityRule";

/**
 * Create a community rule (community_platform_community_rules) for the
 * specified community.
 *
 * This operation inserts a new ordered rule item into the
 * community_platform_community_rules table for the community identified by
 * {communityId}. The schema describes these records as an ordered list authored
 * by the community owner, with order_index unique per community to ensure
 * deterministic display order and text limited to short guidance (1–200
 * characters). The application should atomically persist the new item with
 * proper timestamps.
 *
 * Security and permissions: According to the business rules, only the community
 * owner may create or edit rules. The endpoint therefore requires an
 * authenticated user with ownership over the target community; further
 * authorization checks must be enforced in provider logic. While the endpoint
 * requires authentication (role "communityMember"), only owners pass the
 * ownership check.
 *
 * Relationships and constraints: The newly created rule references
 * community_platform_communities via community_platform_community_id. Providers
 * must ensure that the community exists, is not administratively disabled in a
 * way that forbids settings edits, and that order_index is unique within that
 * community. Input validation must enforce text length (1–200 characters) in
 * accordance with the schema commentary and product constraints.
 *
 * Related operations: Use GET
 * /communityPlatform/communities/{communityId}/rules/{ruleId} to retrieve the
 * created rule, PUT to modify an existing one, and DELETE to remove a rule when
 * necessary.
 *
 * @param props.connection
 * @param props.communityId Parent community’s ID (UUID) that will own the new
 *   rule
 * @param props.body Rule creation payload including order and text constraints
 * @path /communityPlatform/communityMember/communities/:communityId/rules
 * @accessor api.functional.communityPlatform.communityMember.communities.rules.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Parent community’s ID (UUID) that will own the new rule */
    communityId: string & tags.Format<"uuid">;

    /** Rule creation payload including order and text constraints */
    body: ICommunityPlatformCommunityRule.ICreate;
  };
  export type Body = ICommunityPlatformCommunityRule.ICreate;
  export type Response = ICommunityPlatformCommunityRule;

  export const METADATA = {
    method: "POST",
    path: "/communityPlatform/communityMember/communities/:communityId/rules",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPlatform/communityMember/communities/${encodeURIComponent(props.communityId ?? "null")}/rules`;
  export const random = (): ICommunityPlatformCommunityRule =>
    typia.random<ICommunityPlatformCommunityRule>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a community rule in community_platform_community_rules.
 *
 * This operation modifies an existing rule in
 * community_platform_community_rules scoped by the provided {communityId} and
 * {ruleId}. The schema notes that each rule has an order_index (unique per
 * community) and a short text field for display. Updates should ensure that the
 * record remains associated with the same parent community and that constraints
 * are respected.
 *
 * Security and permissions: Editing community rules is restricted to the
 * community owner per the business rules. The endpoint requires an
 * authenticated user (role "communityMember") with ownership verified in
 * business logic. Non-owners attempting to edit must be denied with the
 * standard message.
 *
 * Validation and behavior: Providers should validate that the rule exists, is
 * active (deleted_at IS NULL), and belongs to the specified community. Validate
 * that the new order_index remains unique within the community and that text
 * remains within 1–200 characters. On success, updated_at should reflect the
 * modification. If the rule is missing or already removed, return a not-found
 * outcome at the business layer.
 *
 * Related operations: See GET for retrieval, POST for creation, and DELETE for
 * removal of rules.
 *
 * @param props.connection
 * @param props.communityId Parent community’s ID (UUID) that owns the rule
 * @param props.ruleId Target rule’s ID (UUID) to update
 * @param props.body Rule update payload (e.g., text and/or order_index) subject
 *   to constraints
 * @path /communityPlatform/communityMember/communities/:communityId/rules/:ruleId
 * @accessor api.functional.communityPlatform.communityMember.communities.rules.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Parent community’s ID (UUID) that owns the rule */
    communityId: string & tags.Format<"uuid">;

    /** Target rule’s ID (UUID) to update */
    ruleId: string & tags.Format<"uuid">;

    /**
     * Rule update payload (e.g., text and/or order_index) subject to
     * constraints
     */
    body: ICommunityPlatformCommunityRule.IUpdate;
  };
  export type Body = ICommunityPlatformCommunityRule.IUpdate;
  export type Response = ICommunityPlatformCommunityRule;

  export const METADATA = {
    method: "PUT",
    path: "/communityPlatform/communityMember/communities/:communityId/rules/:ruleId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPlatform/communityMember/communities/${encodeURIComponent(props.communityId ?? "null")}/rules/${encodeURIComponent(props.ruleId ?? "null")}`;
  export const random = (): ICommunityPlatformCommunityRule =>
    typia.random<ICommunityPlatformCommunityRule>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
      assert.param("ruleId")(() => typia.assert(props.ruleId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Logically remove a rule (set deleted_at) in
 * community_platform_community_rules.
 *
 * This operation performs a logical removal of a rule from
 * community_platform_community_rules by setting the deleted_at timestamp for
 * the row identified by {communityId} and {ruleId}. The schema explicitly
 * provides deleted_at as the soft deletion column; records with a non-null
 * value are considered removed from active views and should be excluded from
 * lists and detail retrievals.
 *
 * Security and permissions: Only the community owner is allowed to remove rules
 * per the business requirements. The endpoint requires an authenticated user
 * (role "communityMember"), with ownership verified in provider logic. Attempts
 * by non-owners must be denied using the standard message.
 *
 * Validation and behavior: Providers should ensure the rule exists, belongs to
 * the specified community, and is currently active (deleted_at IS NULL) before
 * performing the logical removal. After removal, the rule should be excluded
 * from feeds, search, and the Community Info + Rules box. If the rule is
 * already removed or not found, respond with the appropriate not-found outcome
 * at the business layer. Because this is a logical removal using deleted_at,
 * the operation does not physically delete the record, preserving
 * auditability.
 *
 * Related operations: Use GET to retrieve existing rules, POST to create new
 * rules, and PUT to edit rules before removal.
 *
 * @param props.connection
 * @param props.communityId Parent community’s ID (UUID) that owns the rule
 * @param props.ruleId Target rule’s ID (UUID) to logically remove
 * @path /communityPlatform/communityMember/communities/:communityId/rules/:ruleId
 * @accessor api.functional.communityPlatform.communityMember.communities.rules.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Parent community’s ID (UUID) that owns the rule */
    communityId: string & tags.Format<"uuid">;

    /** Target rule’s ID (UUID) to logically remove */
    ruleId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/communityPlatform/communityMember/communities/:communityId/rules/:ruleId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/communityMember/communities/${encodeURIComponent(props.communityId ?? "null")}/rules/${encodeURIComponent(props.ruleId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
      assert.param("ruleId")(() => typia.assert(props.ruleId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
