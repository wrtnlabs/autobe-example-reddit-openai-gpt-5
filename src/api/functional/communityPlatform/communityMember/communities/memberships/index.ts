import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformCommunityMembership } from "../../../../../structures/ICommunityPlatformCommunityMembership";
import { IPageICommunityPlatformCommunityMembership } from "../../../../../structures/IPageICommunityPlatformCommunityMembership";

/**
 * Join a community by creating a row in
 * community_platform_community_memberships.
 *
 * Join the target community by creating a new row in
 * community_platform_community_memberships. Per the Prisma schema, memberships
 * record the association between a user and a community and include timestamps
 * created_at and updated_at, with deleted_at indicating an ended membership.
 * The unique composite key on (community_platform_community_id,
 * community_platform_user_id) prevents multiple active memberships.
 *
 * Security and permissions: This action requires authentication and should only
 * allow the authenticated user to create their own membership. Joining confers
 * no moderation privileges; it solely affects personalization and feed
 * inclusion consistent with the product rules. Provider logic should also
 * update community last_active_at
 * (community_platform_communities.last_active_at) where appropriate and may
 * record an audit event in community_platform_audit_logs (e.g., event_type =
 * "join_community").
 *
 * Validation: Validate communityId as a UUID referencing an existing, joinable
 * community (e.g., not administratively disabled via disabled_at where policy
 * forbids new joins). If a membership already exists and is active,
 * implementations should behave idempotently (return the existing membership)
 * or return a conflict depending on policy. If a prior membership exists with
 * deleted_at set, reactivation by clearing deleted_at and updating updated_at
 * can be applied per business rules.
 *
 * Related operations: Use PATCH /communities/{communityId}/memberships for
 * roster queries and DELETE
 * /communities/{communityId}/memberships/{membershipId} to end a membership.
 * These operations operate on the same community_platform_community_memberships
 * table.
 *
 * @param props.connection
 * @param props.communityId Target community’s ID
 *   (community_platform_communities.id)
 * @param props.body Creation payload; the server infers the acting user from
 *   the authenticated session. No additional fields required beyond path
 *   parameter.
 * @path /communityPlatform/communityMember/communities/:communityId/memberships
 * @accessor api.functional.communityPlatform.communityMember.communities.memberships.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Target community’s ID (community_platform_communities.id) */
    communityId: string & tags.Format<"uuid">;

    /**
     * Creation payload; the server infers the acting user from the
     * authenticated session. No additional fields required beyond path
     * parameter.
     */
    body: ICommunityPlatformCommunityMembership.ICreate;
  };
  export type Body = ICommunityPlatformCommunityMembership.ICreate;
  export type Response = ICommunityPlatformCommunityMembership;

  export const METADATA = {
    method: "POST",
    path: "/communityPlatform/communityMember/communities/:communityId/memberships",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPlatform/communityMember/communities/${encodeURIComponent(props.communityId ?? "null")}/memberships`;
  export const random = (): ICommunityPlatformCommunityMembership =>
    typia.random<ICommunityPlatformCommunityMembership>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * List memberships for a community from
 * community_platform_community_memberships with filtering and pagination.
 *
 * Retrieve a filtered, sorted, and paginated list of membership rows from the
 * community_platform_community_memberships junction table. Per the Prisma
 * schema comments, this model captures the relationship between a user
 * (community_platform_users.id) and a community
 * (community_platform_communities.id) and is the source of truth for join/leave
 * history. Columns include id, community_platform_community_id,
 * community_platform_user_id, created_at, updated_at, and a deleted_at
 * timestamp used to indicate that a membership has been ended (leave time). A
 * unique composite index across (community_platform_community_id,
 * community_platform_user_id) prevents duplicate active memberships.
 *
 * Security and permissions: Membership rosters can be sensitive. Although this
 * route is authenticated (authorizationRoles: ["communityMember"]), detailed
 * access should be constrained in the provider to community owners and platform
 * administrators where appropriate. Non-owners may be limited to their own
 * membership state or redacted views. Rate limiting and audit logging
 * (community_platform_audit_logs) are recommended for administrative queries.
 *
 * Entity relationships and behavior: Memberships belong to a community
 * (community_platform_communities) and a user (community_platform_users). The
 * endpoint must filter by the communityId path parameter and should (by
 * default) exclude rows where deleted_at is not null to return currently joined
 * members. When historical queries are needed, the request body can include
 * flags to include ended memberships and to filter by created_at/updated_at
 * ranges. Sorting should support created_at and updated_at fields, and
 * pagination should follow the platform’s standard page/limit or cursor
 * conventions.
 *
 * Validation and error handling: Validate communityId as a UUID that references
 * an existing, not-removed community. If the target community is disabled
 * (disabled_at set), the provider may still allow owners/admins to view the
 * roster but should prevent broader disclosure. Return 404 when the community
 * does not exist, and 400 for invalid parameters. Responses should be stable
 * and deterministic given the sort criteria, and must not include content tied
 * to records with deleted_at when the default active-only filter applies.
 *
 * Related operations: Use POST /communities/{communityId}/memberships to join
 * (create) and DELETE /communities/{communityId}/memberships/{membershipId} to
 * end an existing membership. These operations work against the same
 * community_platform_community_memberships table while enforcing
 * authorship/ownership rules from the requirements.
 *
 * @param props.connection
 * @param props.communityId Target community’s ID
 *   (community_platform_communities.id)
 * @param props.body Search, filter, sort, and pagination parameters for
 *   community memberships
 * @path /communityPlatform/communityMember/communities/:communityId/memberships
 * @accessor api.functional.communityPlatform.communityMember.communities.memberships.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Target community’s ID (community_platform_communities.id) */
    communityId: string & tags.Format<"uuid">;

    /**
     * Search, filter, sort, and pagination parameters for community
     * memberships
     */
    body: ICommunityPlatformCommunityMembership.IRequest;
  };
  export type Body = ICommunityPlatformCommunityMembership.IRequest;
  export type Response = IPageICommunityPlatformCommunityMembership.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/communityPlatform/communityMember/communities/:communityId/memberships",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPlatform/communityMember/communities/${encodeURIComponent(props.communityId ?? "null")}/memberships`;
  export const random =
    (): IPageICommunityPlatformCommunityMembership.ISummary =>
      typia.random<IPageICommunityPlatformCommunityMembership.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * End a community membership in community_platform_community_memberships
 * (logical removal via deleted_at).
 *
 * Remove a user’s membership by marking it ended in the
 * community_platform_community_memberships table. The schema defines deleted_at
 * to capture the leave time, allowing the record to remain available for
 * historical reporting. The membership row includes
 * community_platform_community_id, community_platform_user_id, created_at,
 * updated_at, and deleted_at. This operation must ensure that the membershipId
 * corresponds to the community specified by communityId and that the actor is
 * permitted to end this membership (either the member themself or an authorized
 * community owner/administrator per business rules).
 *
 * Security and permissions: Authentication is required. Authorization checks
 * should confirm that the requester is the membership owner or has sufficient
 * privileges (e.g., community owner or system administrator) to remove another
 * user’s membership. Providers should consider emitting an audit entry in
 * community_platform_audit_logs (event_type like "leave_community" or a policy
 * action for administrative removals) and may refresh community last_active_at
 * on change.
 *
 * Validation and behavior: Validate both communityId and membershipId as UUIDs.
 * If the membership is already ended (deleted_at set), the operation should be
 * idempotent. If membershipId does not belong to the communityId, return 404.
 * If the community is administratively disabled (disabled_at), policy may still
 * permit owners/admins to end memberships. On successful completion, return a
 * 204 No Content with no response body.
 *
 * @param props.connection
 * @param props.communityId Target community’s ID
 *   (community_platform_communities.id)
 * @param props.membershipId Membership row ID
 *   (community_platform_community_memberships.id) to end
 * @path /communityPlatform/communityMember/communities/:communityId/memberships/:membershipId
 * @accessor api.functional.communityPlatform.communityMember.communities.memberships.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Target community’s ID (community_platform_communities.id) */
    communityId: string & tags.Format<"uuid">;

    /**
     * Membership row ID (community_platform_community_memberships.id) to
     * end
     */
    membershipId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/communityPlatform/communityMember/communities/:communityId/memberships/:membershipId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/communityMember/communities/${encodeURIComponent(props.communityId ?? "null")}/memberships/${encodeURIComponent(props.membershipId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
      assert.param("membershipId")(() => typia.assert(props.membershipId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
