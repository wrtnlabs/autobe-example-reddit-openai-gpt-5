import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformPost } from "../../../../../structures/ICommunityPlatformPost";

/**
 * Create a post (community_platform_posts) within a specific community.
 *
 * Create a new post under a specified community. According to the Prisma schema
 * for community_platform_posts, each post belongs to exactly one community
 * (community_platform_community_id) and is authored by a user (author_user_id),
 * with required fields title and body, and an optional author_display_name. The
 * schema describes business constraints at the application layer: title length
 * 5–120 characters and body length 10–10,000 characters as plain text with line
 * breaks only; author display name is optional (0–32 characters) and
 * presentation-only. This API uses the communityId path parameter to resolve
 * the target community (community_platform_communities).
 *
 * Security and permissions: Only authenticated users may create posts.
 * Ownership semantics from the requirements apply: the authenticated user
 * becomes the author of the post and later may edit or delete their own
 * content, while non-authors are denied such actions. Administrative policy
 * actions are separate and recorded elsewhere. Reading is public and unaffected
 * by this creation endpoint.
 *
 * Database relations and lifecycle: The new community_platform_posts record
 * references community_platform_communities (via the path communityId) and
 * community_platform_users (author). Timestamps created_at and updated_at are
 * set on creation. Validation rules from the PRD apply: title/body length
 * limits, plain text only for body, and selection of exactly one target
 * community. Any community identifier in the body, if present, is ignored in
 * favor of the path parameter. The created entity is returned in full detail
 * for client confirmation.
 *
 * Related operations: Use GET /communityPlatform/posts/{postId} to retrieve an
 * individual post. Use PATCH /communityPlatform/posts for listing/searching
 * with pagination and sorting (Newest or Top).
 *
 * @param props.connection
 * @param props.communityId Target community’s ID (UUID) where the post will be
 *   created
 * @param props.body Creation payload for a community-scoped post (title, body,
 *   optional author display name)
 * @path /communityPlatform/communityMember/communities/:communityId/posts
 * @accessor api.functional.communityPlatform.communityMember.communities.posts.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Target community’s ID (UUID) where the post will be created */
    communityId: string & tags.Format<"uuid">;

    /**
     * Creation payload for a community-scoped post (title, body, optional
     * author display name)
     */
    body: ICommunityPlatformPost.ICreate;
  };
  export type Body = ICommunityPlatformPost.ICreate;
  export type Response = ICommunityPlatformPost;

  export const METADATA = {
    method: "POST",
    path: "/communityPlatform/communityMember/communities/:communityId/posts",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPlatform/communityMember/communities/${encodeURIComponent(props.communityId ?? "null")}/posts`;
  export const random = (): ICommunityPlatformPost =>
    typia.random<ICommunityPlatformPost>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
