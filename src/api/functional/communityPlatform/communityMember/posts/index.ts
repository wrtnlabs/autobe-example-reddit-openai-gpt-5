import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformPost } from "../../../../structures/ICommunityPlatformPost";
export * as votes from "./votes/index";
export * as comments from "./comments/index";

/**
 * Create a post (community_platform_posts) via global composer.
 *
 * Create a post via the global composer. Per the community_platform_posts
 * schema, a post requires exactly one target community
 * (community_platform_community_id), a title, and a body, plus optional
 * author_display_name. This endpoint expects the community identifier in the
 * request body (ICommunityPlatformPost.ICreate) and attributes authorship to
 * the authenticated user. Creation timestamps are set accordingly and the new
 * entity is returned in full detail.
 *
 * Security and permissions: Only authenticated users can create posts.
 * Ownership is assigned to the creating user, who can later edit/delete their
 * own post via separate endpoints; non-authors are denied such actions. Guests
 * attempting to create should be prompted to sign in and the action can resume
 * upon successful login as per business requirements.
 *
 * Validation and behavior: Enforce title/body length limits, ensure plain-text
 * body, and require a valid community reference. If the target community cannot
 * be found or is not allowed for posting (e.g., administratively disabled), the
 * server should reject the request according to business rules. On success, the
 * created record is returned to the client.
 *
 * Related operations: Use GET /communityPlatform/posts/{postId} to fetch the
 * created post later. Use PATCH /communityPlatform/posts for search/list and
 * POST /communityPlatform/communityMember/communities/{communityId}/posts for
 * community-scoped creation.
 *
 * @param props.connection
 * @param props.body Creation payload for a globally-composed post, including
 *   target community
 * @path /communityPlatform/communityMember/posts
 * @accessor api.functional.communityPlatform.communityMember.posts.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Creation payload for a globally-composed post, including target
     * community
     */
    body: ICommunityPlatformPost.ICreate;
  };
  export type Body = ICommunityPlatformPost.ICreate;
  export type Response = ICommunityPlatformPost;

  export const METADATA = {
    method: "POST",
    path: "/communityPlatform/communityMember/posts",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/communityPlatform/communityMember/posts";
  export const random = (): ICommunityPlatformPost =>
    typia.random<ICommunityPlatformPost>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing post (community_platform_posts) by ID.
 *
 * Modify a post identified by its UUID, constrained by the business rules
 * defined for Posts. The underlying table is community_platform_posts, which
 * stores title, body, optional author_display_name, created_at, updated_at, and
 * deleted_at among other relations. Only the author is allowed to edit per
 * product rules; attempts by non-authors MUST be rejected with the message:
 * "You can edit or delete only items you authored.". Application logic should
 * set updated_at accordingly and, if implemented, append a snapshot into
 * community_platform_post_snapshots capturing the previous state (title, body,
 * author_display_name) for audit history as suggested by that table’s
 * description.
 *
 * Security and permissions: Authenticated users (role: communityMember) may
 * edit only posts they authored (community_platform_posts.author_user_id equals
 * the requester’s user id). Administrative takedowns are separate policy
 * actions and out of scope for this endpoint. Ownership checks occur in
 * business logic; this documentation focuses on the API contract.
 *
 * Validation and business logic: Title must be 5–120 characters; body must be
 * 10–10,000 characters and remain plain text (no scripts/executable code);
 * author_display_name, when provided, must be 0–32 characters. The community
 * reference (community_platform_community_id) and author_user_id are not
 * changeable here. The response returns the full post entity so clients can
 * immediately reflect changes in feeds and details. Error handling follows
 * standard messages in the requirements: invalid inputs should be reported with
 * clear messages (e.g., "Title must be 5–120 characters.").
 *
 * Relations and consistency: The post belongs to a community via
 * community_platform_community_id and optionally references an author via
 * author_user_id (nullable for anonymization scenarios). This endpoint does not
 * alter votes (community_platform_post_votes) or comments
 * (community_platform_comments); those are managed by dedicated endpoints. On
 * success, updated_at should reflect the edit time to support sorting and
 * auditing.
 *
 * @param props.connection
 * @param props.postId Unique identifier (UUID) of the post to update
 * @param props.body Mutable post fields to update (title, body,
 *   author_display_name)
 * @path /communityPlatform/communityMember/posts/:postId
 * @accessor api.functional.communityPlatform.communityMember.posts.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier (UUID) of the post to update */
    postId: string & tags.Format<"uuid">;

    /** Mutable post fields to update (title, body, author_display_name) */
    body: ICommunityPlatformPost.IUpdate;
  };
  export type Body = ICommunityPlatformPost.IUpdate;
  export type Response = ICommunityPlatformPost;

  export const METADATA = {
    method: "PUT",
    path: "/communityPlatform/communityMember/posts/:postId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPlatform/communityMember/posts/${encodeURIComponent(props.postId ?? "null")}`;
  export const random = (): ICommunityPlatformPost =>
    typia.random<ICommunityPlatformPost>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Remove a post from active access by setting deleted_at in
 * community_platform_posts.
 *
 * Remove a post from active use by marking its deleted_at timestamp in
 * community_platform_posts. The model’s description indicates deleted_at is
 * used to indicate that a record is considered removed from active views. Once
 * marked, the post must be excluded from feeds, search, and the Global Latest
 * materialized view (mv_community_platform_global_latest_posts) on its next
 * refresh.
 *
 * Security and permissions: Only the author of the post may perform this
 * operation in normal flows. If a non-author attempts this action, deny with:
 * "You can edit or delete only items you authored.". Administrative removals
 * (policy takedown) are tracked separately in community_platform_admin_actions
 * and are not part of this endpoint’s contract.
 *
 * Behavior and consistency: Setting deleted_at for the post ensures it will no
 * longer appear in queries. Related comments (community_platform_comments) and
 * votes (community_platform_post_votes) should be ignored by read paths for the
 * deleted post. Implementations may also log to community_platform_audit_logs.
 * This endpoint does not accept a request body and does not return a response
 * body.
 *
 * @param props.connection
 * @param props.postId Unique identifier (UUID) of the post to remove from
 *   active access
 * @path /communityPlatform/communityMember/posts/:postId
 * @accessor api.functional.communityPlatform.communityMember.posts.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier (UUID) of the post to remove from active access */
    postId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/communityPlatform/communityMember/posts/:postId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/communityMember/posts/${encodeURIComponent(props.postId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
