import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformComment } from "../../../structures/ICommunityPlatformComment";
import { IPageICommunityPlatformComment } from "../../../structures/IPageICommunityPlatformComment";
export * as replies from "./replies/index";
export * as history from "./history/index";

/**
 * Search and paginate comments from community_platform_comments.
 *
 * Retrieve a paginated, filterable list of comments from
 * community_platform_comments across all posts. The schema describes id,
 * community_platform_post_id, community_platform_user_id, optional parent_id
 * for nesting, content (plain text), created_at/updated_at, and a deleted_at
 * column for removed comments. This operation supports business search rules:
 * minimum query length for text search (if implemented) and deterministic
 * Newest ordering with tie-breaks.
 *
 * Security and permissions: this is a public read endpoint; authentication is
 * not required. Sensitive author-only operations are out of scope for this
 * endpoint. Records marked removed (deleted_at not null) are not returned.
 *
 * Filtering, sorting, and pagination: clients may filter by post, author,
 * parent (top-level only vs replies), and created_at ranges. Text search can
 * match content with trigram/FTS where available. Sorting is Newest (created_at
 * descending; tie-break by larger identifier when needed). Pagination returns
 * 20 per page by default with page/pageSize and optional cursor support.
 *
 * Error handling: malformed filters (e.g., invalid UUIDs), out-of-range
 * pagination parameters, or too-short search queries yield validation errors
 * with explanatory messages. Related operations include GET
 * /comments/{commentId} for detail and POST /posts/{postId}/comments for
 * creation within a post.
 *
 * @param props.connection
 * @param props.body Search criteria and pagination parameters for comments
 * @path /communityPlatform/comments
 * @accessor api.functional.communityPlatform.comments.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Search criteria and pagination parameters for comments */
    body: ICommunityPlatformComment.IRequest;
  };
  export type Body = ICommunityPlatformComment.IRequest;
  export type Response = IPageICommunityPlatformComment;

  export const METADATA = {
    method: "PATCH",
    path: "/communityPlatform/comments",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/communityPlatform/comments";
  export const random = (): IPageICommunityPlatformComment =>
    typia.random<IPageICommunityPlatformComment>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get a single comment from community_platform_comments by ID.
 *
 * Return a single comment from community_platform_comments identified by
 * commentId. The model contains id, community_platform_post_id (the container
 * post), community_platform_user_id (author), optional parent_id for nested
 * threads, content, created_at/updated_at timestamps, and a deleted_at column.
 * The endpoint exposes the comment only if it is not removed (deleted_at is
 * null).
 *
 * Security: public read access; no authentication required. Ownership and
 * moderation policies impact editing/removal but not this retrieval.
 *
 * Validation and errors: commentId must be a valid UUID. If the comment does
 * not exist or is marked as removed, return a 404. This operation complements
 * PATCH /comments for list/search and PATCH/POST under
 * /posts/{postId}/comments.
 *
 * @param props.connection
 * @param props.commentId Identifier of the target comment
 * @path /communityPlatform/comments/:commentId
 * @accessor api.functional.communityPlatform.comments.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Identifier of the target comment */
    commentId: string & tags.Format<"uuid">;
  };
  export type Response = ICommunityPlatformComment;

  export const METADATA = {
    method: "GET",
    path: "/communityPlatform/comments/:commentId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/comments/${encodeURIComponent(props.commentId ?? "null")}`;
  export const random = (): ICommunityPlatformComment =>
    typia.random<ICommunityPlatformComment>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("commentId")(() => typia.assert(props.commentId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
