import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformComment } from "../../../../structures/ICommunityPlatformComment";
import { IPageICommunityPlatformComment } from "../../../../structures/IPageICommunityPlatformComment";

/**
 * List replies (community_platform_comments) under a parent comment with
 * pagination.
 *
 * List replies for a parent comment using the community_platform_comments
 * table. Each reply record contains fields such as id,
 * community_platform_post_id, community_platform_user_id, parent_id (set to the
 * parent commentâ€™s id), content (plain text), created_at, updated_at, and
 * deleted_at. Only active (deleted_at is null) child comments should be
 * returned. This endpoint focuses on nested threading, returning direct
 * children where parent_id matches the path parameter.
 *
 * This operation is public (no authentication required) because reading
 * comments is open per product rules. It supports pagination and sorting,
 * typically Newest first (by created_at descending with tie-breaking by
 * identifier) and may also support Top depending on business needs. The request
 * body ICommunityPlatformComment.IRequest captures paging, sorting, and any
 * query fields; the response is a paginated list for client-side load-more
 * flows.
 *
 * Business logic must validate the existence of the parent comment and exclude
 * removed entries (deleted_at not null). Errors include invalid identifiers or
 * referencing a non-existent parent. Related operations include creating a
 * reply and updating/deleting comments, which modify this list over time. This
 * list endpoint is commonly used together with post detail views and comment
 * threads.
 *
 * @param props.connection
 * @param props.commentId Parent comment's ID (UUID) whose replies are being
 *   listed
 * @param props.body Search, filtering, sorting, and pagination parameters for
 *   replies
 * @path /communityPlatform/comments/:commentId/replies
 * @accessor api.functional.communityPlatform.comments.replies.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Parent comment's ID (UUID) whose replies are being listed */
    commentId: string & tags.Format<"uuid">;

    /** Search, filtering, sorting, and pagination parameters for replies */
    body: ICommunityPlatformComment.IRequest;
  };
  export type Body = ICommunityPlatformComment.IRequest;
  export type Response = IPageICommunityPlatformComment;

  export const METADATA = {
    method: "PATCH",
    path: "/communityPlatform/comments/:commentId/replies",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPlatform/comments/${encodeURIComponent(props.commentId ?? "null")}/replies`;
  export const random = (): IPageICommunityPlatformComment =>
    typia.random<IPageICommunityPlatformComment>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("commentId")(() => typia.assert(props.commentId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
