import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformPost } from "../../../../structures/ICommunityPlatformPost";
import { IPageICommunityPlatformPost } from "../../../../structures/IPageICommunityPlatformPost";

/**
 * Search posts (community_platform_posts) with sorting and cursor pagination.
 *
 * Search public posts using text matching against the title and body columns of
 * community_platform_posts, returning paginated results suitable for the Posts
 * tab in global search. The underlying Prisma models define posts with fields
 * including id (UUID), title, body, author_display_name, created_at,
 * updated_at, and deleted_at. The posts table is indexed for search with GIN
 * trigram indexes on title and body, and Newest ordering is supported via
 * combined indexes on (created_at, id). This API excludes records where
 * deleted_at is not null to align with visibility rules described in the schema
 * comments.
 *
 * Security and access: This endpoint is public and requires no authentication.
 * Reading is open to everyone, consistent with the business rules.
 * Authorization checks are unnecessary for read-only search results. Standard
 * copy and error handling apply for validation failures and temporary errors,
 * but no sensitive data is exposed. Rate limiting and abuse prevention can be
 * applied at the platform layer.
 *
 * Database relationships: While results come from community_platform_posts,
 * this operation may expose related data commonly shown in cards (e.g.,
 * community name via community_platform_communities and author display name via
 * community_platform_users fields). Score is computed from
 * community_platform_post_votes by aggregating value (+1 for upvote, −1 for
 * downvote) for each post while ignoring votes with deleted_at set. No score
 * column exists in the posts table—scores are derived on the fly. For Top
 * sorting, items are ordered by score desc, then by created_at desc, and
 * finally by id desc when previous keys tie. For Newest, items are ordered by
 * created_at desc and then id desc.
 *
 * Validation and business logic: The request enforces a minimum query length of
 * 2 characters after normalization (trim/diacritics-insensitive, treat
 * hyphen/underscore as token separators) and applies AND semantics across
 * tokens with a prefix match allowed for the final token. Sorting supports
 * sort=newest|top with Newest as the default. Pagination follows the platform’s
 * 20-item page size using an opaque cursor derived from the sort key tuple to
 * guarantee deterministic continuation without duplicates. Items with
 * deleted_at set are excluded, and post visibility respects community deletion
 * by virtue of cascading relationships (posts belong to
 * community_platform_communities with onDelete: Cascade).
 *
 * Related operations and behaviors: Clients often use this endpoint alongside
 * search endpoints for communities and comments, and may also fetch post detail
 * by id for a specific result. Tie-breaker consistency must match the Sorting
 * and Pagination rules: (created_at desc, id desc) for Newest and (score desc,
 * created_at desc, id desc) for Top. Error handling should surface “Please
 * enter at least 2 characters.” for short queries (400) and “A temporary error
 * occurred. Please try again in a moment.” for transient issues (5xx).
 *
 * @param props.connection
 * @param props.body Search criteria for posts including query, sort
 *   (newest|top), and cursor-based pagination (limit defaults to 20).
 * @path /communityPlatform/search/posts
 * @accessor api.functional.communityPlatform.search.posts.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search criteria for posts including query, sort (newest|top), and
     * cursor-based pagination (limit defaults to 20).
     */
    body: ICommunityPlatformPost.IRequest;
  };
  export type Body = ICommunityPlatformPost.IRequest;
  export type Response = IPageICommunityPlatformPost.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/communityPlatform/search/posts",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/communityPlatform/search/posts";
  export const random = (): IPageICommunityPlatformPost.ISummary =>
    typia.random<IPageICommunityPlatformPost.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
